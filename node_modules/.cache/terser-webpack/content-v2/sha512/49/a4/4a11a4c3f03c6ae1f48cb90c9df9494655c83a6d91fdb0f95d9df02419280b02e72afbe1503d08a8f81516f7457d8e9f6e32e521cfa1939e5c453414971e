{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{\"/uSP\":function(e,t,r){const n=r(\"+qE3\").EventEmitter,s=r(\"MCLT\").inherits;function o(){n.call(this),this.isLocked=!0}e.exports=o,s(o,n),o.prototype.go=function(){this.isLocked=!1,this.emit(\"unlock\")},o.prototype.stop=function(){this.isLocked=!0,this.emit(\"lock\")},o.prototype.await=function(e){this.isLocked?this.once(\"unlock\",e):setTimeout(e)}},14:function(e,t){},\"7sdD\":function(e,t,r){\"use strict\";var n=r(\"vgmO\"),s=r(\"g2LC\"),o=r(\"ZESv\"),a=r(\"U6jy\");function i(e,t,r){var n=e;return s(t)?(r=t,\"string\"==typeof e&&(n={uri:e})):n=a(t,{uri:e}),n.callback=r,n}function c(e,t,r){return u(t=i(e,t,r))}function u(e){if(void 0===e.callback)throw new Error(\"callback argument missing\");var t=!1,r=function(r,n,s){t||(t=!0,e.callback(r,n,s))};function n(){var e=void 0;if(e=d.response?d.response:d.responseText||function(e){try{if(\"document\"===e.responseType)return e.responseXML;if(\"\"===e.responseType&&(!e.responseXML||\"parsererror\"!==e.responseXML.documentElement.nodeName))return e.responseXML}catch(t){}return null}(d),y)try{e=JSON.parse(e)}catch(t){}return e}function s(e){return clearTimeout(p),e instanceof Error||(e=new Error(\"\"+(e||\"Unknown XMLHttpRequest Error\"))),e.statusCode=0,r(e,v)}function a(){if(!u){var t;clearTimeout(p);var s=v,a=null;return 0!==(t=e.useXDR&&void 0===d.status?200:1223===d.status?204:d.status)?(s={body:n(),statusCode:t,method:h,headers:{},url:l,rawRequest:d},d.getAllResponseHeaders&&(s.headers=o(d.getAllResponseHeaders()))):a=new Error(\"Internal XMLHttpRequest Error\"),r(a,s,s.body)}}var i,u,d=e.xhr||null;d||(d=e.cors||e.useXDR?new c.XDomainRequest:new c.XMLHttpRequest);var p,l=d.url=e.uri||e.url,h=d.method=e.method||\"GET\",g=e.body||e.data,f=d.headers=e.headers||{},m=!!e.sync,y=!1,v={body:void 0,headers:{},statusCode:0,method:h,url:l,rawRequest:d};if(\"json\"in e&&!1!==e.json&&(y=!0,f.accept||f.Accept||(f.Accept=\"application/json\"),\"GET\"!==h&&\"HEAD\"!==h&&(f[\"content-type\"]||f[\"Content-Type\"]||(f[\"Content-Type\"]=\"application/json\"),g=JSON.stringify(!0===e.json?g:e.json))),d.onreadystatechange=function(){4===d.readyState&&setTimeout(a,0)},d.onload=a,d.onerror=s,d.onprogress=function(){},d.onabort=function(){u=!0},d.ontimeout=s,d.open(h,l,!m,e.username,e.password),m||(d.withCredentials=!!e.withCredentials),!m&&e.timeout>0&&(p=setTimeout(function(){if(!u){u=!0,d.abort(\"timeout\");var e=new Error(\"XMLHttpRequest timeout\");e.code=\"ETIMEDOUT\",s(e)}},e.timeout)),d.setRequestHeader)for(i in f)f.hasOwnProperty(i)&&d.setRequestHeader(i,f[i]);else if(e.headers&&!function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0}(e.headers))throw new Error(\"Headers cannot be set on an XDomainRequest object\");return\"responseType\"in e&&(d.responseType=e.responseType),\"beforeSend\"in e&&\"function\"==typeof e.beforeSend&&e.beforeSend(d),d.send(g||null),d}e.exports=c,e.exports.default=c,c.XMLHttpRequest=n.XMLHttpRequest||function(){},c.XDomainRequest=\"withCredentials\"in new c.XMLHttpRequest?c.XMLHttpRequest:n.XDomainRequest,function(e,t){for(var r=0;r<e.length;r++)t(e[r])}([\"get\",\"put\",\"post\",\"patch\",\"head\",\"delete\"],function(e){c[\"delete\"===e?\"del\":e]=function(t,r,n){return(r=i(t,r,n)).method=e.toUpperCase(),u(r)}})},\"9AHY\":function(e,t,r){const n=r(\"Y+ai\"),s=r(\"NIKR\").rpc.internal,{EthereumRpcError:o}=r(\"9Xsl\"),a=\"Unspecified server error.\",i={code:s,message:c(s)};function c(e,t=\"Unspecified error message. This is a bug, please report it.\"){if(Number.isInteger(e)){const t=e.toString();if(n[t])return n[t].message;if(d(e))return a}return t}function u(e){if(!Number.isInteger(e))return!1;const t=e.toString();return!!n[t]||!!d(e)}function d(e){return e>=-32099&&e<=-32e3}function p(e){return e&&\"object\"==typeof e&&!Array.isArray(e)?Object.assign({},e):e}e.exports={getMessageFromCode:c,isValidCode:u,serializeError:function(e,t=i){if(!t||!Number.isInteger(t.code)||\"string\"!=typeof t.message)throw new Error(\"fallbackError must contain integer number code and string message.\");if(e instanceof o)return e.serialize();const r={};return e&&u(e.code)?(r.code=e.code,e.message&&\"string\"==typeof e.message?(r.message=e.message,e.hasOwnProperty(\"data\")&&(r.data=e.data)):(r.message=c(r.code),r.data={originalError:p(e)})):(r.code=t.code,r.message=e&&e.message?e.message:t.message,r.data={originalError:p(e)}),e&&e.stack&&(r.stack=e.stack),r},JSON_RPC_SERVER_ERROR_MESSAGE:a}},\"9Xsl\":function(e,t,r){const n=r(\"N1pS\");class s extends Error{constructor(e,t,r){if(!Number.isInteger(e))throw new Error('\"code\" must be an integer.');if(!t||\"string\"!=typeof t)throw new Error('\"message\" must be a nonempty string.');super(t),this.code=e,void 0!==r&&(this.data=r)}serialize(){const e={code:this.code,message:this.message};return void 0!==this.data&&(e.data=this.data),this.stack&&(e.stack=this.stack),e}toString(){return n(this.serialize(),o,2)}}function o(e,t){if(\"[Circular]\"!==t)return t}e.exports={EthereumRpcError:s,EthereumProviderError:class extends s{constructor(e,t,r){if(!function(e){return Number.isInteger(e)&&e>=1e3&&e<=4999}(e))throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');super(e,t,r)}}}},EqmL:function(e,t,r){const n=r(\"ja2i\"),s=r(\"t7TP\");e.exports=class extends n{constructor(){super(({blockTracker:e,provider:t,engine:r})=>{const{events:n,middleware:o}=s({blockTracker:e,provider:t});return n.on(\"notification\",e=>r.emit(\"data\",null,e)),o})}}},GKwB:function(e,t,r){const{EthereumRpcError:n,EthereumProviderError:s}=r(\"9Xsl\"),{getMessageFromCode:o}=r(\"9AHY\"),a=r(\"NIKR\");function i(e,t){const[r,s]=u(t);return new n(e,r||o(e),s)}function c(e,t){const[r,n]=u(t);return new s(e,r||o(e),n)}function u(e){let t,r;return e&&(\"string\"==typeof e?t=e:\"object\"!=typeof e||Array.isArray(e)||(t=e.message,r=e.data)),[t,r]}e.exports={rpc:{parse:e=>i(a.rpc.parse,e),invalidRequest:e=>i(a.rpc.invalidRequest,e),invalidParams:e=>i(a.rpc.invalidParams,e),methodNotFound:e=>i(a.rpc.methodNotFound,e),internal:e=>i(a.rpc.internal,e),server:e=>{if(!e||\"object\"!=typeof e||Array.isArray(e))throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");const{code:t}=e;if(!Number.isInteger(t)||t>-32005||t<-32099)throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');return i(t,e)},invalidInput:e=>i(a.rpc.invalidInput,e),resourceNotFound:e=>i(a.rpc.resourceNotFound,e),resourceUnavailable:e=>i(a.rpc.resourceUnavailable,e),transactionRejected:e=>i(a.rpc.transactionRejected,e),methodNotSupported:e=>i(a.rpc.methodNotSupported,e)},provider:{userRejectedRequest:e=>c(a.provider.userRejectedRequest,e),unauthorized:e=>c(a.provider.unauthorized,e),unsupportedMethod:e=>c(a.provider.unsupportedMethod,e),custom:e=>{if(!e||\"object\"!=typeof e||Array.isArray(e))throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");const{code:t,message:r,data:n}=e;if(!r||\"string\"!=typeof r)throw new Error('\"message\" must be a nonempty string');return new s(t,r,n)}}}},IzYE:function(e,t,r){const{EthereumRpcError:n,EthereumProviderError:s}=r(\"9Xsl\"),{serializeError:o,getMessageFromCode:a}=r(\"9AHY\"),i=r(\"GKwB\"),c=r(\"NIKR\");e.exports={ethErrors:i,EthereumRpcError:n,EthereumProviderError:s,serializeError:o,getMessageFromCode:a,ERROR_CODES:c}},NIKR:function(e){e.exports=JSON.parse('{\"rpc\":{\"invalidInput\":-32000,\"resourceNotFound\":-32001,\"resourceUnavailable\":-32002,\"transactionRejected\":-32003,\"methodNotSupported\":-32004,\"parse\":-32700,\"invalidRequest\":-32600,\"methodNotFound\":-32601,\"invalidParams\":-32602,\"internal\":-32603},\"provider\":{\"userRejectedRequest\":4001,\"unauthorized\":4100,\"unsupportedMethod\":4200}}')},Rlsf:function(e,t,r){const n=r(\"l1gh\"),s=r(\"KWkM\"),o=r(\"MCLT\").inherits,a=r(\"/JJz\"),i=r(\"FyGL\"),c=r(\"U6jy\"),u=r(\"odnP\"),d=r(\"Uu7K\"),p=r(\"a5O3\"),l=/^[0-9A-Fa-f]+$/g;function h(e){const t=this;t.nonceLock=u(1),e.getAccounts&&(t.getAccounts=e.getAccounts),e.processTransaction&&(t.processTransaction=e.processTransaction),e.processMessage&&(t.processMessage=e.processMessage),e.processPersonalMessage&&(t.processPersonalMessage=e.processPersonalMessage),e.processTypedMessage&&(t.processTypedMessage=e.processTypedMessage),t.approveTransaction=e.approveTransaction||t.autoApprove,t.approveMessage=e.approveMessage||t.autoApprove,t.approvePersonalMessage=e.approvePersonalMessage||t.autoApprove,t.approveDecryptMessage=e.approveDecryptMessage||t.autoApprove,t.approveEncryptionPublicKey=e.approveEncryptionPublicKey||t.autoApprove,t.approveTypedMessage=e.approveTypedMessage||t.autoApprove,e.signTransaction&&(t.signTransaction=e.signTransaction||v(\"signTransaction\")),e.signMessage&&(t.signMessage=e.signMessage||v(\"signMessage\")),e.signPersonalMessage&&(t.signPersonalMessage=e.signPersonalMessage||v(\"signPersonalMessage\")),e.decryptMessage&&(t.decryptMessage=e.decryptMessage||v(\"decryptMessage\")),e.encryptionPublicKey&&(t.encryptionPublicKey=e.encryptionPublicKey||v(\"encryptionPublicKey\")),e.signTypedMessage&&(t.signTypedMessage=e.signTypedMessage||v(\"signTypedMessage\")),e.recoverPersonalSignature&&(t.recoverPersonalSignature=e.recoverPersonalSignature),e.publishTransaction&&(t.publishTransaction=e.publishTransaction),t.estimateGas=e.estimateGas||t.estimateGas,t.getGasPrice=e.getGasPrice||t.getGasPrice}function g(e){return e.toLowerCase()}function f(e){const t=a.addHexPrefix(e);return a.isValidAddress(t)}function m(e){const t=a.addHexPrefix(e);return!a.isValidAddress(t)&&y(e)}function y(e){return\"string\"==typeof e&&\"0x\"===e.slice(0,2)&&e.slice(2).match(l)}function v(e){return function(t,r){r(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"'+e+'\" fn in constructor options'))}}e.exports=h,o(h,d),h.prototype.handleRequest=function(e,t,r){const s=this;let o,a,i,u,d;switch(s._parityRequests={},s._parityRequestCount=0,e.method){case\"eth_coinbase\":return void s.getAccounts(function(e,t){if(e)return r(e);r(null,t[0]||null)});case\"eth_accounts\":return void s.getAccounts(function(e,t){if(e)return r(e);r(null,t)});case\"eth_sendTransaction\":return o=e.params[0],void n([e=>s.validateTransaction(o,e),e=>s.processTransaction(o,e)],r);case\"eth_signTransaction\":return o=e.params[0],void n([e=>s.validateTransaction(o,e),e=>s.processSignTransaction(o,e)],r);case\"eth_sign\":return d=e.params[0],u=e.params[1],i=e.params[2]||{},a=c(i,{from:d,data:u}),void n([e=>s.validateMessage(a,e),e=>s.processMessage(a,e)],r);case\"personal_sign\":return function(){const t=e.params[0];if(m(e.params[1])&&f(t)){let t=\"The eth_personalSign method requires params ordered \";t+=\"[message, address]. This was previously handled incorrectly, \",t+=\"and has been corrected automatically. \",t+=\"Please switch this param order for smooth behavior in the future.\",console.warn(t),d=e.params[0],u=e.params[1]}else u=e.params[0],d=e.params[1];i=e.params[2]||{},a=c(i,{from:d,data:u}),n([e=>s.validatePersonalMessage(a,e),e=>s.processPersonalMessage(a,e)],r)}();case\"eth_decryptMessage\":return function(){const t=e.params[0];if(m(e.params[1])&&f(t)){let t=\"The eth_decryptMessage method requires params ordered \";t+=\"[message, address]. This was previously handled incorrectly, \",t+=\"and has been corrected automatically. \",t+=\"Please switch this param order for smooth behavior in the future.\",console.warn(t),d=e.params[0],u=e.params[1]}else u=e.params[0],d=e.params[1];i=e.params[2]||{},a=c(i,{from:d,data:u}),n([e=>s.validateDecryptMessage(a,e),e=>s.processDecryptMessage(a,e)],r)}();case\"encryption_public_key\":return function(){const t=e.params[0];n([e=>s.validateEncryptionPublicKey(t,e),e=>s.processEncryptionPublicKey(t,e)],r)}();case\"personal_ecRecover\":return u=e.params[0],i=e.params[2]||{},a=c(i,{sig:e.params[1],data:u}),void s.recoverPersonalSignature(a,r);case\"eth_signTypedData\":case\"eth_signTypedData_v3\":case\"eth_signTypedData_v4\":return function(){const t=e.params[0],o=e.params[1];f(t)?(d=t,u=o):(u=t,d=o),i=e.params[2]||{},a=c(i,{from:d,data:u}),n([e=>s.validateTypedMessage(a,e),e=>s.processTypedMessage(a,e)],r)}();case\"parity_postTransaction\":return o=e.params[0],void s.parityPostTransaction(o,r);case\"parity_postSign\":return d=e.params[0],u=e.params[1],void s.parityPostSign(d,u,r);case\"parity_checkRequest\":return void s.parityCheckRequest(e.params[0],r);case\"parity_defaultAccount\":return void s.getAccounts(function(e,t){if(e)return r(e);r(null,t[0]||null)});default:return void t()}},h.prototype.getAccounts=function(e){e(null,[])},h.prototype.processTransaction=function(e,t){const r=this;n([t=>r.approveTransaction(e,t),(e,t)=>r.checkApproval(\"transaction\",e,t),t=>r.finalizeAndSubmitTx(e,t)],t)},h.prototype.processSignTransaction=function(e,t){const r=this;n([t=>r.approveTransaction(e,t),(e,t)=>r.checkApproval(\"transaction\",e,t),t=>r.finalizeTx(e,t)],t)},h.prototype.processMessage=function(e,t){const r=this;n([t=>r.approveMessage(e,t),(e,t)=>r.checkApproval(\"message\",e,t),t=>r.signMessage(e,t)],t)},h.prototype.processPersonalMessage=function(e,t){const r=this;n([t=>r.approvePersonalMessage(e,t),(e,t)=>r.checkApproval(\"message\",e,t),t=>r.signPersonalMessage(e,t)],t)},h.prototype.processDecryptMessage=function(e,t){const r=this;n([t=>r.approveDecryptMessage(e,t),(e,t)=>r.checkApproval(\"decryptMessage\",e,t),t=>r.decryptMessage(e,t)],t)},h.prototype.processEncryptionPublicKey=function(e,t){const r=this;n([t=>r.approveEncryptionPublicKey(e,t),(e,t)=>r.checkApproval(\"encryptionPublicKey\",e,t),t=>r.encryptionPublicKey(e,t)],t)},h.prototype.processTypedMessage=function(e,t){const r=this;n([t=>r.approveTypedMessage(e,t),(e,t)=>r.checkApproval(\"message\",e,t),t=>r.signTypedMessage(e,t)],t)},h.prototype.autoApprove=function(e,t){t(null,!0)},h.prototype.checkApproval=function(e,t,r){r(t?null:new Error(\"User denied \"+e+\" signature.\"))},h.prototype.parityPostTransaction=function(e,t){const r=this,n=\"0x\"+r._parityRequestCount.toString(16);r._parityRequestCount++,r.emitPayload({method:\"eth_sendTransaction\",params:[e]},function(e,t){r._parityRequests[n]=e?{error:e}:t.result}),t(null,n)},h.prototype.parityPostSign=function(e,t,r){const n=this,s=\"0x\"+n._parityRequestCount.toString(16);n._parityRequestCount++,n.emitPayload({method:\"eth_sign\",params:[e,t]},function(e,t){n._parityRequests[s]=e?{error:e}:t.result}),r(null,s)},h.prototype.parityCheckRequest=function(e,t){const r=this._parityRequests[e]||null;return r?r.error?t(r.error):void t(null,r):t(null,null)},h.prototype.recoverPersonalSignature=function(e,t){let r;try{r=i.recoverPersonalSignature(e)}catch(n){return t(n)}t(null,r)},h.prototype.validateTransaction=function(e,t){if(void 0===e.from)return t(new Error(\"Undefined address - from address required to sign transaction.\"));this.validateSender(e.from,function(r,n){return r?t(r):n?void t():t(new Error(`Unknown address - unable to sign transaction for this address: \"${e.from}\"`))})},h.prototype.validateMessage=function(e,t){if(void 0===e.from)return t(new Error(\"Undefined address - from address required to sign message.\"));this.validateSender(e.from,function(r,n){return r?t(r):n?void t():t(new Error(`Unknown address - unable to sign message for this address: \"${e.from}\"`))})},h.prototype.validatePersonalMessage=function(e,t){return void 0===e.from?t(new Error(\"Undefined address - from address required to sign personal message.\")):void 0===e.data?t(new Error(\"Undefined message - message required to sign personal message.\")):y(e.data)?void this.validateSender(e.from,function(r,n){return r?t(r):n?void t():t(new Error(`Unknown address - unable to sign message for this address: \"${e.from}\"`))}):t(new Error(\"HookedWalletSubprovider - validateMessage - message was not encoded as hex.\"))},h.prototype.validateDecryptMessage=function(e,t){return void 0===e.from?t(new Error(\"Undefined address - from address required to decrypt message.\")):void 0===e.data?t(new Error(\"Undefined message - message required to decrypt message.\")):y(e.data)?void this.validateSender(e.from,function(r,n){return r?t(r):n?void t():t(new Error(`Unknown address - unable to decrypt message for this address: \"${e.from}\"`))}):t(new Error(\"HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.\"))},h.prototype.validateEncryptionPublicKey=function(e,t){this.validateSender(e,function(r,n){return r?t(r):n?void t():t(new Error(`Unknown address - unable to obtain encryption public key for this address: \"${e}\"`))})},h.prototype.validateTypedMessage=function(e,t){return void 0===e.from?t(new Error(\"Undefined address - from address required to sign typed data.\")):void 0===e.data?t(new Error(\"Undefined data - message required to sign typed data.\")):void this.validateSender(e.from,function(r,n){return r?t(r):n?void t():t(new Error(`Unknown address - unable to sign message for this address: \"${e.from}\"`))})},h.prototype.validateSender=function(e,t){if(!e)return t(null,!1);this.getAccounts(function(r,n){if(r)return t(r);const s=-1!==n.map(g).indexOf(e.toLowerCase());t(null,s)})},h.prototype.finalizeAndSubmitTx=function(e,t){const r=this;r.nonceLock.take(function(){n([r.fillInTxExtras.bind(r,e),r.signTransaction.bind(r),r.publishTransaction.bind(r)],function(e,n){if(r.nonceLock.leave(),e)return t(e);t(null,n)})})},h.prototype.finalizeTx=function(e,t){const r=this;r.nonceLock.take(function(){n([r.fillInTxExtras.bind(r,e),r.signTransaction.bind(r)],function(n,s){if(r.nonceLock.leave(),n)return t(n);t(null,{raw:s,tx:e})})})},h.prototype.publishTransaction=function(e,t){this.emitPayload({method:\"eth_sendRawTransaction\",params:[e]},function(e,r){if(e)return t(e);t(null,r.result)})},h.prototype.estimateGas=function(e,t){p(this.engine,e,t)},h.prototype.getGasPrice=function(e){this.emitPayload({method:\"eth_gasPrice\",params:[]},function(t,r){if(t)return e(t);e(null,r.result)})},h.prototype.fillInTxExtras=function(e,t){const r=this,n=e.from,o={};void 0===e.gasPrice&&(o.gasPrice=r.getGasPrice.bind(r)),void 0===e.nonce&&(o.nonce=r.emitPayload.bind(r,{method:\"eth_getTransactionCount\",params:[n,\"pending\"]})),void 0===e.gas&&(o.gas=r.estimateGas.bind(r,function(e){return{from:e.from,to:e.to,value:e.value,data:e.data,gas:e.gas,gasPrice:e.gasPrice,nonce:e.nonce}}(e))),s(o,function(r,n){if(r)return t(r);const s={};n.gasPrice&&(s.gasPrice=n.gasPrice),n.nonce&&(s.nonce=n.nonce.result),n.gas&&(s.gas=n.gas),t(null,c(e,s))})}},Uu7K:function(e,t,r){const n=r(\"xQaN\");function s(){}e.exports=s,s.prototype.setEngine=function(e){const t=this;t.engine||(t.engine=e,e.on(\"block\",function(e){t.currentBlock=e}),e.on(\"start\",function(){t.start()}),e.on(\"stop\",function(){t.stop()}))},s.prototype.handleRequest=function(e,t,r){throw new Error(\"Subproviders should override `handleRequest`.\")},s.prototype.emitPayload=function(e,t){this.engine.sendAsync(n(e),t)},s.prototype.stop=function(){},s.prototype.start=function(){}},WPTD:function(e,t,r){const n=process.browser?r(\"7sdD\"):r(14),s=r(\"MCLT\").inherits,o=r(\"xQaN\"),a=r(\"Uu7K\"),{ethErrors:i,serializeError:c}=r(\"IzYE\");function u(e){this.rpcUrl=e.rpcUrl}e.exports=u,s(u,a),u.prototype.handleRequest=function(e,t,r){const s=this.rpcUrl,a=function(e){return{id:e.id,jsonrpc:e.jsonrpc,method:e.method,params:e.params}}(e),u=o(a);n({uri:s,method:\"POST\",headers:{Accept:\"application/json\",\"Content-Type\":\"application/json\"},body:JSON.stringify(u),rejectUnauthorized:!1,timeout:2e4},function(e,t,n){if(e)return r(c(e));switch(t.statusCode){case 405:return r(i.rpc.methodNotFound());case 504:return function(){let e=\"Gateway timeout. The request took too long to process. \";e+=\"This can happen when querying logs over too wide a block range.\";const t=new Error(\"Gateway timeout. The request took too long to process. This can happen when querying logs over too wide a block range.\");return r(c(t))}();case 429:return function(){const e=new Error(\"Too Many Requests\");return r(c(e))}();default:if(200!=t.statusCode){const e=new Error(\"Unknown Error: \"+t.body);return r(c(e))}}let s;try{s=JSON.parse(n)}catch(e){return console.error(e.stack),r(c(e))}if(s.error)return r(s.error);r(null,s.result)})}},\"Y+ai\":function(e){e.exports=JSON.parse('{\"4001\":{\"standard\":\"EIP 1193\",\"message\":\"User rejected the request.\"},\"4100\":{\"standard\":\"EIP 1193\",\"message\":\"The requested account and/or method has not been authorized by the user.\"},\"4200\":{\"standard\":\"EIP 1193\",\"message\":\"The requested method is not supported by this Ethereum provider.\"},\"-32700\":{\"standard\":\"JSON RPC 2.0\",\"message\":\"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"},\"-32600\":{\"standard\":\"JSON RPC 2.0\",\"message\":\"The JSON sent is not a valid Request object.\"},\"-32601\":{\"standard\":\"JSON RPC 2.0\",\"message\":\"The method does not exist / is not available.\"},\"-32602\":{\"standard\":\"JSON RPC 2.0\",\"message\":\"Invalid method parameter(s).\"},\"-32603\":{\"standard\":\"JSON RPC 2.0\",\"message\":\"Internal JSON-RPC error.\"},\"-32000\":{\"standard\":\"EIP 1474\",\"message\":\"Invalid input.\"},\"-32001\":{\"standard\":\"EIP 1474\",\"message\":\"Resource not found.\"},\"-32002\":{\"standard\":\"EIP 1474\",\"message\":\"Resource unavailable.\"},\"-32003\":{\"standard\":\"EIP 1474\",\"message\":\"Transaction rejected.\"},\"-32004\":{\"standard\":\"EIP 1474\",\"message\":\"Method not supported.\"}}')},ZESv:function(e,t){var r=function(e){return e.replace(/^\\s+|\\s+$/g,\"\")};e.exports=function(e){if(!e)return{};for(var t={},n=r(e).split(\"\\n\"),s=0;s<n.length;s++){var o=n[s],a=o.indexOf(\":\"),i=r(o.slice(0,a)).toLowerCase(),c=r(o.slice(a+1));void 0===t[i]?t[i]=c:\"[object Array]\"===Object.prototype.toString.call(t[i])?t[i].push(c):t[i]=[t[i],c]}return t}},a5O3:function(e,t,r){const n=r(\"xQaN\");e.exports=function(e,t,r){e.sendAsync(n({method:\"eth_estimateGas\",params:[t]}),function(e,t){if(e)return\"no contract code at given address\"===e.message?r(null,\"0xcf08\"):r(e);r(null,t.result)})}},\"cC/c\":function(e,t,r){const n=r(\"ja2i\"),s=r(\"2nhq\");e.exports=class extends n{constructor(){super(({blockTracker:e,provider:t})=>s({blockTracker:e,provider:t}))}}},f4g2:function(e,t,r){const n=r(\"+qE3\").EventEmitter,s=r(\"MCLT\").inherits,o=r(\"/JJz\"),a=r(\"V5x4\"),i=r(\"LCem\"),c=r(\"YOJA\"),u=r(\"/uSP\"),d=(r(\"gO+T\"),r(\"xQaN\")),p=function(){};function l(e){const t=this;n.call(t),t.setMaxListeners(30),e=e||{};const r={sendAsync:t._handleAsync.bind(t)};t._blockTracker=e.blockTracker||new a({provider:e.blockTrackerProvider||r,pollingInterval:e.pollingInterval||4e3,setSkipCacheFlag:!0}),t._ready=new u,t.currentBlock=null,t._providers=[]}e.exports=l,s(l,n),l.prototype.start=function(e=p){const t=this;t._ready.go(),t._blockTracker.on(\"latest\",e=>{t._getBlockByNumberWithRetry(e,(e,r)=>{if(e)return void this.emit(\"error\",e);if(!r)return console.log(r),void this.emit(\"error\",new Error(\"Could not find block\"));const n={number:o.toBuffer((s=r).number),hash:o.toBuffer(s.hash),parentHash:o.toBuffer(s.parentHash),nonce:o.toBuffer(s.nonce),mixHash:o.toBuffer(s.mixHash),sha3Uncles:o.toBuffer(s.sha3Uncles),logsBloom:o.toBuffer(s.logsBloom),transactionsRoot:o.toBuffer(s.transactionsRoot),stateRoot:o.toBuffer(s.stateRoot),receiptsRoot:o.toBuffer(s.receiptRoot||s.receiptsRoot),miner:o.toBuffer(s.miner),difficulty:o.toBuffer(s.difficulty),totalDifficulty:o.toBuffer(s.totalDifficulty),size:o.toBuffer(s.size),extraData:o.toBuffer(s.extraData),gasLimit:o.toBuffer(s.gasLimit),gasUsed:o.toBuffer(s.gasUsed),timestamp:o.toBuffer(s.timestamp),transactions:s.transactions};var s;t._setCurrentBlock(n),t.emit(\"rawBlock\",r),t.emit(\"latest\",r)})}),t._blockTracker.on(\"sync\",t.emit.bind(t,\"sync\")),t._blockTracker.on(\"error\",t.emit.bind(t,\"error\")),t._running=!0,t.emit(\"start\")},l.prototype.stop=function(){const e=this;e._blockTracker.removeAllListeners(),e._running=!1,e.emit(\"stop\")},l.prototype.isRunning=function(){return this._running},l.prototype.addProvider=function(e,t){\"number\"==typeof t?this._providers.splice(t,0,e):this._providers.push(e),e.setEngine(this)},l.prototype.removeProvider=function(e){const t=this._providers.indexOf(e);if(t<0)throw new Error(\"Provider not found.\");this._providers.splice(t,1)},l.prototype.send=function(e){throw new Error(\"Web3ProviderEngine does not support synchronous requests.\")},l.prototype.sendAsync=function(e,t){const r=this;r._ready.await(function(){Array.isArray(e)?i(e,r._handleAsync.bind(r),t):r._handleAsync(e,t)})},l.prototype._getBlockByNumberWithRetry=function(e,t){const r=this;let n=5;return void s();function s(){r._getBlockByNumber(e,o)}function o(e,r){return e?t(e):r?void t(null,r):n>0?(n--,void setTimeout(function(){s()},1e3)):void t(null,null)}},l.prototype._getBlockByNumber=function(e,t){const r=d({method:\"eth_getBlockByNumber\",params:[e,!1],skipCache:!0});this._handleAsync(r,(e,r)=>e?t(e):t(null,r.result))},l.prototype._handleAsync=function(e,t){var r=this,n=-1,s=null,o=null,a=[];function i(r,n){o=r,s=n,c(a,function(e,t){e?e(o,s,t):t()},function(){var r={id:e.id,jsonrpc:e.jsonrpc,result:s};null!=o?(r.error={message:o.stack||o.message||o,code:-32e3},t(o,r)):t(null,r)})}!function t(s){if(n+=1,a.unshift(s),n>=r._providers.length)i(new Error('Request for method \"'+e.method+'\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));else try{r._providers[n].handleRequest(e,t,i)}catch(o){i(o)}}()},l.prototype._setCurrentBlock=function(e){this.currentBlock=e,this.emit(\"block\",e)}},g2LC:function(e,t){e.exports=function(e){if(!e)return!1;var t=r.call(e);return\"[object Function]\"===t||\"function\"==typeof e&&\"[object RegExp]\"!==t||\"undefined\"!=typeof window&&(e===window.setTimeout||e===window.alert||e===window.confirm||e===window.prompt)};var r=Object.prototype.toString},\"gO+T\":function(e,t,r){const n=r(\"rE/H\");function s(e){return\"never\"!==i(e)}function o(e){var t=a(e);return t>=e.params.length?e.params:\"eth_getBlockByNumber\"===e.method?e.params.slice(1):e.params.slice(0,t)}function a(e){switch(e.method){case\"eth_getStorageAt\":return 2;case\"eth_getBalance\":case\"eth_getCode\":case\"eth_getTransactionCount\":case\"eth_call\":case\"eth_estimateGas\":return 1;case\"eth_getBlockByNumber\":return 0;default:return}}function i(e){switch(e.method){case\"web3_clientVersion\":case\"web3_sha3\":case\"eth_protocolVersion\":case\"eth_getBlockTransactionCountByHash\":case\"eth_getUncleCountByBlockHash\":case\"eth_getCode\":case\"eth_getBlockByHash\":case\"eth_getTransactionByHash\":case\"eth_getTransactionByBlockHashAndIndex\":case\"eth_getTransactionReceipt\":case\"eth_getUncleByBlockHashAndIndex\":case\"eth_getCompilers\":case\"eth_compileLLL\":case\"eth_compileSolidity\":case\"eth_compileSerpent\":case\"shh_version\":return\"perma\";case\"eth_getBlockByNumber\":case\"eth_getBlockTransactionCountByNumber\":case\"eth_getUncleCountByBlockNumber\":case\"eth_getTransactionByBlockNumberAndIndex\":case\"eth_getUncleByBlockNumberAndIndex\":return\"fork\";case\"eth_gasPrice\":case\"eth_getBalance\":case\"eth_getStorageAt\":case\"eth_getTransactionCount\":case\"eth_call\":case\"eth_estimateGas\":case\"eth_getFilterLogs\":case\"eth_getLogs\":case\"eth_blockNumber\":return\"block\";case\"net_version\":case\"net_peerCount\":case\"net_listening\":case\"eth_syncing\":case\"eth_sign\":case\"eth_coinbase\":case\"eth_mining\":case\"eth_hashrate\":case\"eth_accounts\":case\"eth_sendTransaction\":case\"eth_sendRawTransaction\":case\"eth_newFilter\":case\"eth_newBlockFilter\":case\"eth_newPendingTransactionFilter\":case\"eth_uninstallFilter\":case\"eth_getFilterChanges\":case\"eth_getWork\":case\"eth_submitWork\":case\"eth_submitHashrate\":case\"db_putString\":case\"db_getString\":case\"db_putHex\":case\"db_getHex\":case\"shh_post\":case\"shh_newIdentity\":case\"shh_hasIdentity\":case\"shh_newGroup\":case\"shh_addToGroup\":case\"shh_newFilter\":case\"shh_uninstallFilter\":case\"shh_getFilterChanges\":case\"shh_getMessages\":return\"never\"}}e.exports={cacheIdentifierForPayload:function(e,t={}){if(!s(e))return null;const{includeBlockRef:r}=t,a=r?e.params:o(e);return e.method+\":\"+n(a)},canCache:s,blockTagForPayload:function(e){var t=a(e);return t>=e.params.length?null:e.params[t]},paramsWithoutBlockTag:o,blockTagParamIndex:a,cacheTypeForPayload:i}},jYfc:function(e,t,r){\"use strict\";r.r(t),r(\"ls82\");var n=r(\"D0PL\"),s=(r(\"kB5k\"),r(\"/TMw\"),r(\"M39V\"),r(\"f4g2\")),o=r.n(s),a=r(\"WPTD\"),i=r.n(a),c=r(\"Rlsf\"),u=r.n(c),d=r(\"EqmL\"),p=r.n(d),l=r(\"cC/c\"),h=r.n(l);t.default=function(e){var t=e.getAccounts,r=e.signTransaction,s=e.rpcUrl,a=e.processMessage,c=e.processPersonalMessage,d=e.signMessage,l=e.signPersonalMessage,g=e.signTypedMessage,f=Object(n.i)(n.c).blockPollingInterval,m=t&&new u.a({getAccounts:t,signTransaction:r,processMessage:a,processPersonalMessage:c,signMessage:d,signPersonalMessage:l,signTypedMessage:g}),y=new i.a({rpcUrl:s.includes(\"http\")?s:\"https://\".concat(s)}),v=new o.a({pollingInterval:f});return v.addProvider(new p.a),v.addProvider(new h.a),m&&v.addProvider(m),v.addProvider(y),v.start(),v.on(\"error\",console.error),v}},ja2i:function(e,t,r){const n=r(\"Uu7K\");e.exports=class extends n{constructor(e){if(super(),!e)throw new Error(\"JsonRpcEngineMiddlewareSubprovider - no constructorFn specified\");this._constructorFn=e}setEngine(e){if(this.middleware)throw new Error(\"JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice\");const t=this._constructorFn({engine:e,provider:e,blockTracker:e._blockTracker});if(!t)throw new Error(\"JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware\");if(\"function\"!=typeof t)throw new Error(\"JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function\");this.middleware=t}handleRequest(e,t,r){const n={id:e.id};this.middleware(e,n,function(e){t((t,r,s)=>{t?(delete n.result,n.error={message:t.message||t}):n.result=r,e?e(s):s()})},function(e){if(e)return r(e);r(null,n.result)})}}},\"kzD/\":function(e,t){e.exports=function(){return Math.floor(Number.MAX_SAFE_INTEGER*Math.random())}},vgmO:function(e,t){var r;r=\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{},e.exports=r},xQaN:function(e,t,r){const n=r(\"kzD/\"),s=r(\"U6jy\");e.exports=function(e){return s({id:n(),jsonrpc:\"2.0\",params:[]},e)}}}]);","name":"8.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[8],{\n\n/***/ \"/uSP\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst EventEmitter = __webpack_require__(\"+qE3\").EventEmitter\nconst inherits = __webpack_require__(\"MCLT\").inherits\n\nmodule.exports = Stoplight\n\n\ninherits(Stoplight, EventEmitter)\n\nfunction Stoplight(){\n  const self = this\n  EventEmitter.call(self)\n  self.isLocked = true\n}\n\nStoplight.prototype.go = function(){\n  const self = this\n  self.isLocked = false\n  self.emit('unlock')\n}\n\nStoplight.prototype.stop = function(){\n  const self = this\n  self.isLocked = true\n  self.emit('lock')\n}\n\nStoplight.prototype.await = function(fn){\n  const self = this\n  if (self.isLocked) {\n    self.once('unlock', fn)\n  } else {\n    setTimeout(fn)\n  }\n}\n\n/***/ }),\n\n/***/ 14:\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ \"7sdD\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar window = __webpack_require__(\"vgmO\")\nvar isFunction = __webpack_require__(\"g2LC\")\nvar parseHeaders = __webpack_require__(\"ZESv\")\nvar xtend = __webpack_require__(\"U6jy\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n\n\n/***/ }),\n\n/***/ \"9AHY\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\nconst errorValues = __webpack_require__(\"Y+ai\")\nconst FALLBACK_ERROR_CODE = __webpack_require__(\"NIKR\").rpc.internal\nconst { EthereumRpcError } = __webpack_require__(\"9Xsl\")\n\nconst JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.'\n\nconst FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.'\n\nconst FALLBACK_ERROR = {\n  code: FALLBACK_ERROR_CODE,\n  message: getMessageFromCode(FALLBACK_ERROR_CODE)\n}\n\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n * \n * @param {number} code - The integer error code\n * @param {string} fallbackMessage - The fallback message\n * @return {string} The corresponding message or the fallback message\n */\nfunction getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\n\n  if (Number.isInteger(code)) {\n\n    const codeString = code.toString()\n    if (errorValues[codeString]) return errorValues[codeString].message\n\n    if (isJsonRpcServerError(code)) return JSON_RPC_SERVER_ERROR_MESSAGE\n\n    // TODO: allow valid codes and messages to be extended\n    // // EIP 1193 Status Codes\n    // if (code >= 4000 && code <= 4999) return Something?\n  }\n  return fallbackMessage\n}\n\n/**\n * Returns whether the given code is valid.\n * A code is only valid if it has a message.\n * \n * @param {number} code - The code to check\n * @return {boolean} true if the code is valid, false otherwise.\n */\nfunction isValidCode(code) {\n\n  if (!Number.isInteger(code)) return false\n\n  const codeString = code.toString()\n  if (errorValues[codeString]) return true\n\n  if (isJsonRpcServerError(code)) return true\n\n  // TODO: allow valid codes and messages to be extended\n  // // EIP 1193 Status Codes\n  // if (code >= 4000 && code <= 4999) return true\n\n  return false\n}\n\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * Merely copies the given error's values if it is already compatible.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.originalError property.\n * Adds a 'stack' property if it exists on the given error.\n *\n * @param {any} error - The error to serialize.\n * @param {object} fallbackError - The custom fallback error values if the\n * given error is invalid.\n * @return {object} A standardized error object.\n */\nfunction serializeError (error, fallbackError = FALLBACK_ERROR) {\n\n  if (\n    !fallbackError || \n    !Number.isInteger(fallbackError.code) ||\n    typeof fallbackError.message !== 'string'\n  ) {\n    throw new Error(\n      'fallbackError must contain integer number code and string message.'\n    )\n  }\n\n  if (error instanceof EthereumRpcError) {\n    return error.serialize()\n  }\n\n  const serialized = {}\n\n  if (error && isValidCode(error.code)) {\n\n    serialized.code = error.code\n\n    if (error.message && typeof error.message === 'string') {\n      serialized.message = error.message\n      if (error.hasOwnProperty('data')) serialized.data = error.data\n    } else {\n      serialized.message = getMessageFromCode(serialized.code)\n      serialized.data = { originalError: assignOriginalError(error) }\n    }\n\n  } else {\n    serialized.code = fallbackError.code\n    serialized.message = (\n      error && error.message\n        ? error.message\n        : fallbackError.message\n    )\n    serialized.data = { originalError: assignOriginalError(error) }\n  }\n\n  if (error && error.stack) serialized.stack = error.stack\n  return serialized\n}\n\n// Internal\n\nfunction isJsonRpcServerError (code) {\n  return code >= -32099 && code <= -32000\n}\n\nfunction assignOriginalError (error) {\n  if (error && typeof error === 'object' && !Array.isArray(error)) {\n    return Object.assign({}, error)\n  }\n  return error\n}\n\n// Exports\n\nmodule.exports = {\n  getMessageFromCode,\n  isValidCode,\n  serializeError,\n  JSON_RPC_SERVER_ERROR_MESSAGE,\n}\n\n\n/***/ }),\n\n/***/ \"9Xsl\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\nconst safeStringify = __webpack_require__(\"N1pS\")\n\n/**\n * @class JsonRpcError\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP 1474.\n * Permits any integer error code.\n */\nclass EthereumRpcError extends Error {\n\n  /**\n   * Create an Ethereum JSON RPC error.\n   * \n   * @param {number} code - The integer error code.\n   * @param {string} message - The string message.\n   * @param {any} [data] - The error data.\n   */\n  constructor (code, message, data) {\n\n    if (!Number.isInteger(code)) throw new Error(\n      '\"code\" must be an integer.'\n    )\n    if (!message || typeof message !== 'string') throw new Error(\n      '\"message\" must be a nonempty string.'\n    )\n\n    super(message)\n    this.code = code\n    if (data !== undefined) this.data = data\n  }\n\n  /**\n   * Returns a plain object with all public class properties.\n   * \n   * @returns {object} The serialized error. \n   */\n  serialize() {\n    const serialized = {\n      code: this.code,\n      message: this.message,\n    }\n    if (this.data !== undefined) serialized.data = this.data\n    if (this.stack) serialized.stack = this.stack\n    return serialized\n  }\n\n  /**\n   * Return a string representation of the serialized error, omitting\n   * any circular references.\n   * \n   * @returns {string} The serialized error as a string.\n   */\n  toString() {\n    return safeStringify(\n      this.serialize(),\n      stringifyReplacer,\n      2\n    )\n  }\n}\n\n/**\n * @class EthereumRpcError\n * Error subclass implementing Ethereum Provider errors per EIP 1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */\nclass EthereumProviderError extends EthereumRpcError {\n\n  /**\n   * Create an Ethereum JSON RPC error.\n   * \n   * @param {number} code - The integer error code, in the [ 1000 <= 4999 ] range.\n   * @param {string} message - The string message.\n   * @param {any} [data] - The error data.\n   */\n  constructor(code, message, data) {\n\n    if (!isValidEthProviderCode(code)) {\n      throw new Error(\n        '\"code\" must be an integer such that: 1000 <= code <= 4999'\n      )\n    }\n\n    super(code, message, data)\n  }\n}\n\n// Internal\n\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999\n}\n\nfunction stringifyReplacer(_, value) {\n  if (value === '[Circular]') {\n    return\n  }\n  return value\n}\n\n// Exports\n\nmodule.exports =  {\n  EthereumRpcError,\n  EthereumProviderError\n}\n\n\n/***/ }),\n\n/***/ \"EqmL\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst ProviderSubprovider = __webpack_require__(\"ja2i\")\nconst createSubscriptionManager = __webpack_require__(\"t7TP\")\n\nclass SubscriptionsSubprovider extends ProviderSubprovider {\n  constructor() {\n    super(({ blockTracker, provider, engine }) => {\n      const { events, middleware } = createSubscriptionManager({ blockTracker, provider })\n      // forward subscription events on the engine\n      events.on('notification', (data) => engine.emit('data', null, data))\n      // return the subscription install/remove middleware\n      return middleware\n    })\n  }\n}\n\nmodule.exports = SubscriptionsSubprovider\n\n\n/***/ }),\n\n/***/ \"GKwB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\nconst { EthereumRpcError, EthereumProviderError } = __webpack_require__(\"9Xsl\")\nconst { getMessageFromCode } = __webpack_require__(\"9AHY\")\nconst ERROR_CODES = __webpack_require__(\"NIKR\")\n\nmodule.exports = {\n  rpc: {\n    /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    parse: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.parse, opts\n    ),\n\n    /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    invalidRequest: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.invalidRequest, opts\n    ),\n\n    /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    invalidParams: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.invalidParams, opts\n    ),\n\n    /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    methodNotFound: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.methodNotFound, opts\n    ),\n\n    /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    internal: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.internal, opts\n    ),\n\n    /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP 1474.\n     * \n     * @param {Object|string} opts - Options object\n     * @param {number} opts.code - The error code\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    server: (opts) => {\n      if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n        throw new Error('Ethereum RPC Server errors must provide single object argument.')\n      }\n      const { code } = opts\n      if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n        throw new Error(\n          '\"code\" must be an integer such that: -32099 <= code <= -32005'\n        )\n      }\n      return getEthJsonRpcError(code, opts)\n    },\n\n    /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    invalidInput: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.invalidInput, opts\n    ),\n\n    /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    resourceNotFound: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.resourceNotFound, opts\n    ),\n\n    /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    resourceUnavailable: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.resourceUnavailable, opts\n    ),\n\n    /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    transactionRejected: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.transactionRejected, opts\n    ),\n\n    /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumRpcError} The error\n     */\n    methodNotSupported: (opts) => getEthJsonRpcError(\n      ERROR_CODES.rpc.methodNotSupported, opts\n    ),\n  },\n\n  provider: {\n    /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumProviderError} The error\n     */\n    userRejectedRequest: (opts) => {\n      return getEthProviderError(\n        ERROR_CODES.provider.userRejectedRequest, opts\n      )\n    },\n\n    /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumProviderError} The error\n     */\n    unauthorized: (opts) => {\n      return getEthProviderError(\n        ERROR_CODES.provider.unauthorized, opts\n      )\n    },\n\n    /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     * \n     * @param {Object|string} [opts] - Options object or error message string\n     * @param {string} [opts.message] - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumProviderError} The error\n     */\n    unsupportedMethod: (opts) => {\n      return getEthProviderError(\n        ERROR_CODES.provider.unsupportedMethod, opts\n      )\n    },\n\n    /**\n     * Get a custom Ethereum Provider error.\n     * \n     * @param {Object|string} opts - Options object\n     * @param {number} opts.code - The error code\n     * @param {string} opts.message - The error message\n     * @param {any} [opts.data] - Error data\n     * @returns {EthereumProviderError} The error\n     */\n    custom: (opts) => {\n      if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n        throw new Error('Ethereum Provider custom errors must provide single object argument.')\n      }\n      const { code, message, data } = opts\n      if (!message || typeof message !== 'string') throw new Error(\n        '\"message\" must be a nonempty string'\n      )\n      return new EthereumProviderError(code, message, data)\n    },\n  },\n}\n\n// Internal\n\nfunction getEthJsonRpcError(code, opts) {\n  const [ message, data ] = validateOpts(opts)\n  return new EthereumRpcError(\n    code,\n    message || getMessageFromCode(code),\n    data\n  )\n}\n\nfunction getEthProviderError(code, opts) {\n  const [ message, data ] = validateOpts(opts)\n  return new EthereumProviderError(\n    code,\n    message || getMessageFromCode(code),\n    data\n  )\n}\n\nfunction validateOpts (opts) {\n  let message, data\n  if (opts) {\n    if (typeof opts === 'string') {\n      message = opts\n    } else if (typeof opts === 'object' && !Array.isArray(opts)) {\n      message = opts.message\n      data = opts.data\n    }\n  }\n  return [ message, data ]\n}\n\n\n/***/ }),\n\n/***/ \"IzYE\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\nconst { EthereumRpcError, EthereumProviderError } = __webpack_require__(\"9Xsl\")\nconst {\n  serializeError, getMessageFromCode,\n} = __webpack_require__(\"9AHY\")\nconst ethErrors = __webpack_require__(\"GKwB\")\nconst ERROR_CODES = __webpack_require__(\"NIKR\")\n\nmodule.exports = {\n  ethErrors,\n  EthereumRpcError,\n  EthereumProviderError,\n  serializeError,\n  getMessageFromCode,\n  /** @type ErrorCodes */\n  ERROR_CODES,\n}\n\n// Types\n\n/**\n * @typedef {Object} EthereumProviderErrorCodes\n * @property {number} userRejectedRequest\n * @property {number} unauthorized\n * @property {number} unsupportedMethod\n */\n\n/**\n * @typedef {Object} EthereumRpcErrorCodes\n * @property {number} parse\n * @property {number} invalidRequest\n * @property {number} invalidParams\n * @property {number} methodNotFound\n * @property {number} internal\n * @property {number} invalidInput\n * @property {number} resourceNotFound\n * @property {number} resourceUnavailable\n * @property {number} transactionRejected\n * @property {number} methodNotSupported\n */\n\n/**\n * @typedef ErrorCodes\n * @property {EthereumRpcErrorCodes} rpc\n * @property {EthereumProviderErrorCodes} provider\n */\n\n\n/***/ }),\n\n/***/ \"NIKR\":\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"rpc\\\":{\\\"invalidInput\\\":-32000,\\\"resourceNotFound\\\":-32001,\\\"resourceUnavailable\\\":-32002,\\\"transactionRejected\\\":-32003,\\\"methodNotSupported\\\":-32004,\\\"parse\\\":-32700,\\\"invalidRequest\\\":-32600,\\\"methodNotFound\\\":-32601,\\\"invalidParams\\\":-32602,\\\"internal\\\":-32603},\\\"provider\\\":{\\\"userRejectedRequest\\\":4001,\\\"unauthorized\\\":4100,\\\"unsupportedMethod\\\":4200}}\");\n\n/***/ }),\n\n/***/ \"Rlsf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\n\nconst waterfall = __webpack_require__(\"l1gh\")\nconst parallel = __webpack_require__(\"KWkM\")\nconst inherits = __webpack_require__(\"MCLT\").inherits\nconst ethUtil = __webpack_require__(\"/JJz\")\nconst sigUtil = __webpack_require__(\"FyGL\")\nconst extend = __webpack_require__(\"U6jy\")\nconst Semaphore = __webpack_require__(\"odnP\")\nconst Subprovider = __webpack_require__(\"Uu7K\")\nconst estimateGas = __webpack_require__(\"a5O3\")\nconst hexRegex = /^[0-9A-Fa-f]+$/g\n\nmodule.exports = HookedWalletSubprovider\n\n// handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   eth_signTypedData_v3\n//   eth_signTypedData_v4\n//   personal_sign\n//   eth_decryptMessage\n//   encryption_public_key\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\n\ninherits(HookedWalletSubprovider, Subprovider)\n\nfunction HookedWalletSubprovider(opts){\n  const self = this\n  // control flow\n  self.nonceLock = Semaphore(1)\n\n  // data lookup\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts\n  // high level override\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction\n  if (opts.processMessage) self.processMessage = opts.processMessage\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage\n  // approval hooks\n  self.approveTransaction = opts.approveTransaction || self.autoApprove\n  self.approveMessage = opts.approveMessage || self.autoApprove\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove\n  self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove\n  self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove\n  // actually perform the signature\n  if (opts.signTransaction) self.signTransaction = opts.signTransaction  || mustProvideInConstructor('signTransaction')\n  if (opts.signMessage) self.signMessage = opts.signMessage  || mustProvideInConstructor('signMessage')\n  if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage  || mustProvideInConstructor('signPersonalMessage')\n  if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage  || mustProvideInConstructor('decryptMessage')\n  if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey  || mustProvideInConstructor('encryptionPublicKey')\n  if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage  || mustProvideInConstructor('signTypedMessage')\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature\n  // publish to network\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction\n  // gas options\n  self.estimateGas = opts.estimateGas || self.estimateGas\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice\n}\n\nHookedWalletSubprovider.prototype.handleRequest = function(payload, next, end){\n  const self = this\n  self._parityRequests = {}\n  self._parityRequestCount = 0\n\n  // switch statement is not block scoped\n  // sp we cant repeat var declarations\n  let txParams, msgParams, extraParams\n  let message, address\n\n  switch(payload.method) {\n\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        let result = accounts[0] || null\n        end(null, result)\n      })\n      return\n\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        end(null, accounts)\n      })\n      return\n\n    case 'eth_sendTransaction':\n      txParams = payload.params[0]\n      waterfall([\n        (cb) => self.validateTransaction(txParams, cb),\n        (cb) => self.processTransaction(txParams, cb),\n      ], end)\n      return\n\n    case 'eth_signTransaction':\n      txParams = payload.params[0]\n      waterfall([\n        (cb) => self.validateTransaction(txParams, cb),\n        (cb) => self.processSignTransaction(txParams, cb),\n      ], end)\n      return\n\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0]\n      message = payload.params[1]\n      // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n      extraParams = payload.params[2] || {}\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message,\n      })\n      waterfall([\n        (cb) => self.validateMessage(msgParams, cb),\n        (cb) => self.processMessage(msgParams, cb),\n      ], end)\n      return\n\n    case 'personal_sign':\n      return (function(){\n        // process normally\n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_personalSign method requires params ordered `\n          warning += `[message, address]. This was previously handled incorrectly, `\n          warning += `and has been corrected automatically. `\n          warning += `Please switch this param order for smooth behavior in the future.`\n          console.warn(warning)\n\n          address = payload.params[0]\n          message = payload.params[1]\n        } else {\n          message = payload.params[0]\n          address = payload.params[1]\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validatePersonalMessage(msgParams, cb),\n          (cb) => self.processPersonalMessage(msgParams, cb),\n        ], end)\n      })()\n\n    case 'eth_decryptMessage':\n      return (function(){\n        // process normally\n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_decryptMessage method requires params ordered `\n          warning += `[message, address]. This was previously handled incorrectly, `\n          warning += `and has been corrected automatically. `\n          warning += `Please switch this param order for smooth behavior in the future.`\n          console.warn(warning)\n\n          address = payload.params[0]\n          message = payload.params[1]\n        } else {\n          message = payload.params[0]\n          address = payload.params[1]\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validateDecryptMessage(msgParams, cb),\n          (cb) => self.processDecryptMessage(msgParams, cb),\n        ], end)\n      })()\n      \n    case 'encryption_public_key':\n      return (function(){\n        const address = payload.params[0]\n        \n        waterfall([\n          (cb) => self.validateEncryptionPublicKey(address, cb),\n          (cb) => self.processEncryptionPublicKey(address, cb),\n        ], end)\n      })()\n      \n    case 'personal_ecRecover':\n      return (function(){    \n        message = payload.params[0]\n        let signature = payload.params[1]\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message,\n        })\n        self.recoverPersonalSignature(msgParams, end)\n      })()\n\n    case 'eth_signTypedData':\n    case 'eth_signTypedData_v3':\n    case 'eth_signTypedData_v4':\n      return (function(){ \n        // process normally\n      \n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        if (resemblesAddress(first)) {\n          address = first\n          message = second\n        } else {\n          message = first\n          address = second\n        }\n\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validateTypedMessage(msgParams, cb),\n          (cb) => self.processTypedMessage(msgParams, cb),\n        ], end)\n      })()\n\n    case 'parity_postTransaction':\n      txParams = payload.params[0]\n      self.parityPostTransaction(txParams, end)\n      return\n\n    case 'parity_postSign':\n      address = payload.params[0]\n      message = payload.params[1]\n      self.parityPostSign(address, message, end)\n      return\n\n    case 'parity_checkRequest':\n      return (function(){\n        const requestId = payload.params[0]\n        self.parityCheckRequest(requestId, end)\n      })()\n\n    case 'parity_defaultAccount':\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        const account = accounts[0] || null\n        end(null, account)\n      })\n      return\n\n    default:\n      next()\n      return\n\n  }\n}\n\n//\n// data lookup\n//\n\nHookedWalletSubprovider.prototype.getAccounts = function(cb) {\n  cb(null, [])\n}\n\n\n//\n// \"process\" high level flow\n//\n\nHookedWalletSubprovider.prototype.processTransaction = function(txParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTransaction(txParams, cb),\n    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),\n    (cb) => self.finalizeAndSubmitTx(txParams, cb),\n  ], cb)\n}\n\n\nHookedWalletSubprovider.prototype.processSignTransaction = function(txParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTransaction(txParams, cb),\n    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),\n    (cb) => self.finalizeTx(txParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processPersonalMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approvePersonalMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signPersonalMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processDecryptMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveDecryptMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('decryptMessage', didApprove, cb),\n    (cb) => self.decryptMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processEncryptionPublicKey = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveEncryptionPublicKey(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('encryptionPublicKey', didApprove, cb),\n    (cb) => self.encryptionPublicKey(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processTypedMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTypedMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signTypedMessage(msgParams, cb),\n  ], cb)\n}\n\n//\n// approval\n//\n\nHookedWalletSubprovider.prototype.autoApprove = function(txParams, cb) {\n  cb(null, true)\n}\n\nHookedWalletSubprovider.prototype.checkApproval = function(type, didApprove, cb) {\n  cb( didApprove ? null : new Error('User denied '+type+' signature.') )\n}\n\n//\n// parity\n//\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function(txParams, cb) {\n  const self = this\n\n  // get next id\n  const count = self._parityRequestCount\n  const reqId = `0x${count.toString(16)}`\n  self._parityRequestCount++\n\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams],\n  }, function(error, res){\n    if (error) {\n      self._parityRequests[reqId] = { error }\n      return\n    }\n    const txHash = res.result\n    self._parityRequests[reqId] = txHash\n  })\n\n  cb(null, reqId)\n}\n\n\nHookedWalletSubprovider.prototype.parityPostSign = function(address, message, cb) {\n  const self = this\n\n  // get next id\n  const count = self._parityRequestCount\n  const reqId = `0x${count.toString(16)}`\n  self._parityRequestCount++\n\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message],\n  }, function(error, res){\n    if (error) {\n      self._parityRequests[reqId] = { error }\n      return\n    }\n    const result = res.result\n    self._parityRequests[reqId] = result\n  })\n\n  cb(null, reqId)\n}\n\nHookedWalletSubprovider.prototype.parityCheckRequest = function(reqId, cb) {\n  const self = this\n  const result = self._parityRequests[reqId] || null\n  // tx not handled yet\n  if (!result) return cb(null, null)\n  // tx was rejected (or other error)\n  if (result.error) return cb(result.error)\n  // tx sent\n  cb(null, result)\n}\n\n//\n// signature and recovery\n//\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function(msgParams, cb) {\n  let senderHex\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams)\n  } catch (err) {\n    return cb(err)\n  }\n  cb(null, senderHex)\n}\n\n//\n// validation\n//\n\nHookedWalletSubprovider.prototype.validateTransaction = function(txParams, cb){\n  const self = this\n  // shortcut: undefined sender is invalid\n  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`))\n  self.validateSender(txParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: \"${txParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validatePersonalMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`))\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateDecryptMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to decrypt message.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to decrypt message.`))\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to decrypt message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateEncryptionPublicKey = function(address, cb){\n  const self = this\n\n  self.validateSender(address, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: \"${address}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateTypedMessage = function(msgParams, cb){\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`))\n  this.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateSender = function(senderAddress, cb){\n  const self = this\n  // shortcut: undefined sender is invalid\n  if (!senderAddress) return cb(null, false)\n  self.getAccounts(function(err, accounts){\n    if (err) return cb(err)\n    const senderIsValid = (accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1)\n    cb(null, senderIsValid)\n  })\n}\n\n//\n// tx helpers\n//\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function(txParams, cb) {\n  const self = this\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function(){\n    waterfall([\n      self.fillInTxExtras.bind(self, txParams),\n      self.signTransaction.bind(self),\n      self.publishTransaction.bind(self),\n    ], function(err, txHash){\n      self.nonceLock.leave()\n      if (err) return cb(err)\n      cb(null, txHash)\n    })\n  })\n}\n\nHookedWalletSubprovider.prototype.finalizeTx = function(txParams, cb) {\n  const self = this\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function(){\n    waterfall([\n      self.fillInTxExtras.bind(self, txParams),\n      self.signTransaction.bind(self),\n    ], function(err, signedTx){\n      self.nonceLock.leave()\n      if (err) return cb(err)\n      cb(null, {raw: signedTx, tx: txParams})\n    })\n  })\n}\n\nHookedWalletSubprovider.prototype.publishTransaction = function(rawTx, cb) {\n  const self = this\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx],\n  }, function(err, res){\n    if (err) return cb(err)\n    cb(null, res.result)\n  })\n}\n\nHookedWalletSubprovider.prototype.estimateGas = function(txParams, cb) {\n  const self = this\n  estimateGas(self.engine, txParams, cb)\n}\n\nHookedWalletSubprovider.prototype.getGasPrice = function(cb) {\n  const self = this\n  self.emitPayload({ method: 'eth_gasPrice', params: [] }, function (err, res) {\n    if (err) return cb(err)\n    cb(null, res.result)\n  })\n}\n\nHookedWalletSubprovider.prototype.fillInTxExtras = function(txParams, cb){\n  const self = this\n  const address = txParams.from\n  // console.log('fillInTxExtras - address:', address)\n\n  const tasks = {}\n\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self)\n  }\n\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, { method: 'eth_getTransactionCount', params: [address, 'pending'] })\n  }\n\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams))\n  }\n\n  parallel(tasks, function(err, taskResults) {\n    if (err) return cb(err)\n\n    const result = {}\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result\n    if (taskResults.gas) result.gas = taskResults.gas\n\n    cb(null, extend(txParams, result))\n  })\n}\n\n// util\n\n// we use this to clean any custom params from the txParams\nfunction cloneTxParams(txParams){\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce,\n  }\n}\n\nfunction toLowerCase(string){\n  return string.toLowerCase()\n}\n\nfunction resemblesAddress (string) {\n  const fixed = ethUtil.addHexPrefix(string)\n  const isValid = ethUtil.isValidAddress(fixed)\n  return isValid\n}\n\n// Returns true if resembles hex data\n// but definitely not a valid address.\nfunction resemblesData (string) {\n  const fixed = ethUtil.addHexPrefix(string)\n  const isValidAddress = ethUtil.isValidAddress(fixed)\n  return !isValidAddress && isValidHex(string)\n}\n\nfunction isValidHex(data) {\n  const isString = typeof data === 'string'\n  if (!isString) return false\n  const isHexPrefixed = data.slice(0,2) === '0x'\n  if (!isHexPrefixed) return false\n  const nonPrefixed = data.slice(2)\n  const isValid = nonPrefixed.match(hexRegex)\n  return isValid\n}\n\nfunction mustProvideInConstructor(methodName) {\n  return function(params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'))\n  }\n}\n\n\n/***/ }),\n\n/***/ \"Uu7K\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst createPayload = __webpack_require__(\"xQaN\")\n\nmodule.exports = SubProvider\n\n// this is the base class for a subprovider -- mostly helpers\n\n\nfunction SubProvider() {\n\n}\n\nSubProvider.prototype.setEngine = function(engine) {\n  const self = this\n  if (self.engine) return\n  self.engine = engine\n  engine.on('block', function(block) {\n    self.currentBlock = block\n  })\n\n  engine.on('start', function () {\n    self.start()\n  })\n\n  engine.on('stop', function () {\n    self.stop()\n  })\n}\n\nSubProvider.prototype.handleRequest = function(payload, next, end) {\n  throw new Error('Subproviders should override `handleRequest`.')\n}\n\nSubProvider.prototype.emitPayload = function(payload, cb){\n  const self = this\n  self.engine.sendAsync(createPayload(payload), cb)\n}\n\n// dummies for overriding\n\nSubProvider.prototype.stop = function () {}\n\nSubProvider.prototype.start = function () {}\n\n\n/***/ }),\n\n/***/ \"WPTD\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst xhr = process.browser ? __webpack_require__(\"7sdD\") : __webpack_require__(14)\nconst inherits = __webpack_require__(\"MCLT\").inherits\nconst createPayload = __webpack_require__(\"xQaN\")\nconst Subprovider = __webpack_require__(\"Uu7K\")\nconst { ethErrors, serializeError } = __webpack_require__(\"IzYE\")\n\n\nmodule.exports = RpcSource\n\ninherits(RpcSource, Subprovider)\n\nfunction RpcSource(opts) {\n  const self = this\n  self.rpcUrl = opts.rpcUrl\n}\n\nRpcSource.prototype.handleRequest = function(payload, next, end){\n  const self = this\n  const targetUrl = self.rpcUrl\n\n  // overwrite id to conflict with other concurrent users\n  const sanitizedPayload = sanitizePayload(payload)\n  const newPayload = createPayload(sanitizedPayload)\n\n  xhr({\n    uri: targetUrl,\n    method: 'POST',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(newPayload),\n    rejectUnauthorized: false,\n    timeout: 20000,\n  }, function(err, res, body) {\n    if (err) return end(serializeError(err))\n\n    // check for error code\n    switch (res.statusCode) {\n      case 405:\n        return end(ethErrors.rpc.methodNotFound())\n      case 504: // Gateway timeout\n        return (function(){\n          let msg = `Gateway timeout. The request took too long to process. `\n          msg += `This can happen when querying logs over too wide a block range.`\n          const err = new Error(msg)\n          return end(serializeError(err))\n        })()\n      case 429: // Too many requests (rate limiting)\n        return (function(){\n          const err = new Error(`Too Many Requests`)\n          return end(serializeError(err))\n        })()\n      default:\n        if (res.statusCode != 200) {\n          const msg = 'Unknown Error: ' + res.body\n          const err = new Error(msg)\n          return end(serializeError(err))\n        }\n    }\n\n    // parse response\n    let data\n    try {\n      data = JSON.parse(body)\n    } catch (err) {\n      console.error(err.stack)\n      return end(serializeError(err))\n    }\n    if (data.error) return end(data.error)\n\n    end(null, data.result)\n  })\n}\n\n// drops any non-standard params\nfunction sanitizePayload (payload) {\n  return {\n    id: payload.id,\n    jsonrpc: payload.jsonrpc,\n    method: payload.method,\n    params: payload.params,\n  }\n}\n\n/***/ }),\n\n/***/ \"Y+ai\":\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"4001\\\":{\\\"standard\\\":\\\"EIP 1193\\\",\\\"message\\\":\\\"User rejected the request.\\\"},\\\"4100\\\":{\\\"standard\\\":\\\"EIP 1193\\\",\\\"message\\\":\\\"The requested account and/or method has not been authorized by the user.\\\"},\\\"4200\\\":{\\\"standard\\\":\\\"EIP 1193\\\",\\\"message\\\":\\\"The requested method is not supported by this Ethereum provider.\\\"},\\\"-32700\\\":{\\\"standard\\\":\\\"JSON RPC 2.0\\\",\\\"message\\\":\\\"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\\\"},\\\"-32600\\\":{\\\"standard\\\":\\\"JSON RPC 2.0\\\",\\\"message\\\":\\\"The JSON sent is not a valid Request object.\\\"},\\\"-32601\\\":{\\\"standard\\\":\\\"JSON RPC 2.0\\\",\\\"message\\\":\\\"The method does not exist / is not available.\\\"},\\\"-32602\\\":{\\\"standard\\\":\\\"JSON RPC 2.0\\\",\\\"message\\\":\\\"Invalid method parameter(s).\\\"},\\\"-32603\\\":{\\\"standard\\\":\\\"JSON RPC 2.0\\\",\\\"message\\\":\\\"Internal JSON-RPC error.\\\"},\\\"-32000\\\":{\\\"standard\\\":\\\"EIP 1474\\\",\\\"message\\\":\\\"Invalid input.\\\"},\\\"-32001\\\":{\\\"standard\\\":\\\"EIP 1474\\\",\\\"message\\\":\\\"Resource not found.\\\"},\\\"-32002\\\":{\\\"standard\\\":\\\"EIP 1474\\\",\\\"message\\\":\\\"Resource unavailable.\\\"},\\\"-32003\\\":{\\\"standard\\\":\\\"EIP 1474\\\",\\\"message\\\":\\\"Transaction rejected.\\\"},\\\"-32004\\\":{\\\"standard\\\":\\\"EIP 1474\\\",\\\"message\\\":\\\"Method not supported.\\\"}}\");\n\n/***/ }),\n\n/***/ \"ZESv\":\n/***/ (function(module, exports) {\n\nvar trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n\n\n/***/ }),\n\n/***/ \"a5O3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst createPayload = __webpack_require__(\"xQaN\")\n\nmodule.exports = estimateGas\n\n/*\n\nThis is a work around for https://github.com/ethereum/go-ethereum/issues/2577\n\n*/\n\n\nfunction estimateGas(provider, txParams, cb) {\n  provider.sendAsync(createPayload({\n    method: 'eth_estimateGas',\n    params: [txParams]\n  }), function(err, res){\n    if (err) {\n      // handle simple value transfer case\n      if (err.message === 'no contract code at given address') {\n        return cb(null, '0xcf08')\n      } else {\n        return cb(err)        \n      }\n    }\n    cb(null, res.result)\n  })\n}\n\n/***/ }),\n\n/***/ \"cC/c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst ProviderSubprovider = __webpack_require__(\"ja2i\")\nconst createFilterMiddleware = __webpack_require__(\"2nhq\")\n\nclass SubscriptionsSubprovider extends ProviderSubprovider {\n  constructor() {\n    super(({ blockTracker, provider, engine }) => {\n      return createFilterMiddleware({ blockTracker, provider })\n    })\n  }\n}\n\nmodule.exports = SubscriptionsSubprovider\n\n\n/***/ }),\n\n/***/ \"f4g2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst EventEmitter = __webpack_require__(\"+qE3\").EventEmitter\nconst inherits = __webpack_require__(\"MCLT\").inherits\nconst ethUtil = __webpack_require__(\"/JJz\")\nconst EthBlockTracker = __webpack_require__(\"V5x4\")\nconst map = __webpack_require__(\"LCem\")\nconst eachSeries = __webpack_require__(\"YOJA\")\nconst Stoplight = __webpack_require__(\"/uSP\")\nconst cacheUtils = __webpack_require__(\"gO+T\")\nconst createPayload = __webpack_require__(\"xQaN\")\nconst noop = function(){}\n\nmodule.exports = Web3ProviderEngine\n\n\ninherits(Web3ProviderEngine, EventEmitter)\n\nfunction Web3ProviderEngine(opts) {\n  const self = this\n  EventEmitter.call(self)\n  self.setMaxListeners(30)\n  // parse options\n  opts = opts || {}\n\n  // block polling\n  const directProvider = { sendAsync: self._handleAsync.bind(self) }\n  const blockTrackerProvider = opts.blockTrackerProvider || directProvider\n  self._blockTracker = opts.blockTracker || new EthBlockTracker({\n    provider: blockTrackerProvider,\n    pollingInterval: opts.pollingInterval || 4000,\n    setSkipCacheFlag: true,\n  })\n\n  // set initialization blocker\n  self._ready = new Stoplight()\n\n  // local state\n  self.currentBlock = null\n  self._providers = []\n}\n\n// public\n\nWeb3ProviderEngine.prototype.start = function(cb = noop){\n  const self = this\n\n  // trigger start\n  self._ready.go()\n\n  // on new block, request block body and emit as events\n  self._blockTracker.on('latest', (blockNumber) => {\n    // get block body\n    self._getBlockByNumberWithRetry(blockNumber, (err, block) => {\n      if (err) {\n        this.emit('error', err)\n        return\n      }\n      if (!block) {\n        console.log(block)\n        this.emit('error', new Error(\"Could not find block\"))\n        return\n      }\n      const bufferBlock = toBufferBlock(block)\n      // set current + emit \"block\" event\n      self._setCurrentBlock(bufferBlock)\n      // emit other events\n      self.emit('rawBlock', block)\n      self.emit('latest', block)\n    })\n  })\n\n  // forward other events\n  self._blockTracker.on('sync', self.emit.bind(self, 'sync'))\n  self._blockTracker.on('error', self.emit.bind(self, 'error'))\n\n  // update state\n  self._running = true\n  // signal that we started\n  self.emit('start')\n}\n\nWeb3ProviderEngine.prototype.stop = function(){\n  const self = this\n  // stop block polling by removing event listeners\n  self._blockTracker.removeAllListeners()\n  // update state\n  self._running = false\n  // signal that we stopped\n  self.emit('stop')\n}\n\nWeb3ProviderEngine.prototype.isRunning = function(){\n  const self = this\n  return self._running\n}\n\nWeb3ProviderEngine.prototype.addProvider = function(source, index){\n  const self = this\n  if (typeof index === 'number') {\n    self._providers.splice(index, 0, source)\n  } else {\n    self._providers.push(source)\n  }\n  source.setEngine(this)\n}\n\nWeb3ProviderEngine.prototype.removeProvider = function(source){\n  const self = this\n  const index = self._providers.indexOf(source)\n  if (index < 0) throw new Error('Provider not found.')\n  self._providers.splice(index, 1)\n}\n\nWeb3ProviderEngine.prototype.send = function(payload){\n  throw new Error('Web3ProviderEngine does not support synchronous requests.')\n}\n\nWeb3ProviderEngine.prototype.sendAsync = function(payload, cb){\n  const self = this\n  self._ready.await(function(){\n\n    if (Array.isArray(payload)) {\n      // handle batch\n      map(payload, self._handleAsync.bind(self), cb)\n    } else {\n      // handle single\n      self._handleAsync(payload, cb)\n    }\n\n  })\n}\n\n// private\n\nWeb3ProviderEngine.prototype._getBlockByNumberWithRetry = function(blockNumber, cb) {\n  const self = this\n\n  let retriesRemaining = 5\n\n  attemptRequest()\n  return\n\n  function attemptRequest () {\n    self._getBlockByNumber(blockNumber, afterRequest)\n  }\n\n  function afterRequest (err, block) {\n    // anomalous error occurred\n    if (err) return cb(err)\n    // block not ready yet\n    if (!block) {\n      if (retriesRemaining > 0) {\n        // wait 1s then try again\n        retriesRemaining--\n        setTimeout(function () {\n          attemptRequest()\n        }, 1000)\n        return\n      } else {\n        // give up, return a null block\n        cb(null, null)\n        return\n      }\n    }\n    // otherwise return result\n    cb(null, block)\n    return\n  }\n}\n\n\nWeb3ProviderEngine.prototype._getBlockByNumber = function(blockNumber, cb) {\n  const req = createPayload({ method: 'eth_getBlockByNumber', params: [blockNumber, false], skipCache: true })\n  this._handleAsync(req, (err, res) => {\n    if (err) return cb(err)\n    return cb(null, res.result)\n  })\n}\n\nWeb3ProviderEngine.prototype._handleAsync = function(payload, finished) {\n  var self = this\n  var currentProvider = -1\n  var result = null\n  var error = null\n\n  var stack = []\n\n  next()\n\n  function next(after) {\n    currentProvider += 1\n    stack.unshift(after)\n\n    // Bubbled down as far as we could go, and the request wasn't\n    // handled. Return an error.\n    if (currentProvider >= self._providers.length) {\n      end(new Error('Request for method \"' + payload.method + '\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'))\n    } else {\n      try {\n        var provider = self._providers[currentProvider]\n        provider.handleRequest(payload, next, end)\n      } catch (e) {\n        end(e)\n      }\n    }\n  }\n\n  function end(_error, _result) {\n    error = _error\n    result = _result\n\n    eachSeries(stack, function(fn, callback) {\n\n      if (fn) {\n        fn(error, result, callback)\n      } else {\n        callback()\n      }\n    }, function() {\n\n      var resultObj = {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        result: result\n      }\n\n      if (error != null) {\n        resultObj.error = {\n          message: error.stack || error.message || error,\n          code: -32000\n        }\n        // respond with both error formats\n        finished(error, resultObj)\n      } else {\n        finished(null, resultObj)\n      }\n    })\n  }\n}\n\n//\n// from remote-data\n//\n\nWeb3ProviderEngine.prototype._setCurrentBlock = function(block){\n  const self = this\n  self.currentBlock = block\n  self.emit('block', block)\n}\n\n// util\n\nfunction toBufferBlock (jsonBlock) {\n  return {\n    number:           ethUtil.toBuffer(jsonBlock.number),\n    hash:             ethUtil.toBuffer(jsonBlock.hash),\n    parentHash:       ethUtil.toBuffer(jsonBlock.parentHash),\n    nonce:            ethUtil.toBuffer(jsonBlock.nonce),\n    mixHash:          ethUtil.toBuffer(jsonBlock.mixHash),\n    sha3Uncles:       ethUtil.toBuffer(jsonBlock.sha3Uncles),\n    logsBloom:        ethUtil.toBuffer(jsonBlock.logsBloom),\n    transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),\n    stateRoot:        ethUtil.toBuffer(jsonBlock.stateRoot),\n    receiptsRoot:     ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),\n    miner:            ethUtil.toBuffer(jsonBlock.miner),\n    difficulty:       ethUtil.toBuffer(jsonBlock.difficulty),\n    totalDifficulty:  ethUtil.toBuffer(jsonBlock.totalDifficulty),\n    size:             ethUtil.toBuffer(jsonBlock.size),\n    extraData:        ethUtil.toBuffer(jsonBlock.extraData),\n    gasLimit:         ethUtil.toBuffer(jsonBlock.gasLimit),\n    gasUsed:          ethUtil.toBuffer(jsonBlock.gasUsed),\n    timestamp:        ethUtil.toBuffer(jsonBlock.timestamp),\n    transactions:     jsonBlock.transactions,\n  }\n}\n\n\n/***/ }),\n\n/***/ \"g2LC\":\n/***/ (function(module, exports) {\n\nmodule.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  if (!fn) {\n    return false\n  }\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n\n\n/***/ }),\n\n/***/ \"gO+T\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst stringify = __webpack_require__(\"rE/H\")\n\nmodule.exports = {\n  cacheIdentifierForPayload: cacheIdentifierForPayload,\n  canCache: canCache,\n  blockTagForPayload: blockTagForPayload,\n  paramsWithoutBlockTag: paramsWithoutBlockTag,\n  blockTagParamIndex: blockTagParamIndex,\n  cacheTypeForPayload: cacheTypeForPayload,\n}\n\nfunction cacheIdentifierForPayload(payload, opts = {}){\n  if (!canCache(payload)) return null\n  const { includeBlockRef } = opts\n  const params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload)\n  return payload.method + ':' + stringify(params)\n}\n\nfunction canCache(payload){\n  return cacheTypeForPayload(payload) !== 'never'\n}\n\nfunction blockTagForPayload(payload){\n  var index = blockTagParamIndex(payload);\n\n  // Block tag param not passed.\n  if (index >= payload.params.length) {\n    return null;\n  }\n\n  return payload.params[index];\n}\n\nfunction paramsWithoutBlockTag(payload){\n  var index = blockTagParamIndex(payload);\n\n  // Block tag param not passed.\n  if (index >= payload.params.length) {\n    return payload.params;\n  }\n\n  // eth_getBlockByNumber has the block tag first, then the optional includeTx? param\n  if (payload.method === 'eth_getBlockByNumber') {\n    return payload.params.slice(1);\n  }\n\n  return payload.params.slice(0,index);\n}\n\nfunction blockTagParamIndex(payload){\n  switch(payload.method) {\n    // blockTag is third param\n    case 'eth_getStorageAt':\n      return 2\n    // blockTag is second param\n    case 'eth_getBalance':\n    case 'eth_getCode':\n    case 'eth_getTransactionCount':\n    case 'eth_call':\n    case 'eth_estimateGas':\n      return 1\n    // blockTag is first param\n    case 'eth_getBlockByNumber':\n      return 0\n    // there is no blockTag\n    default:\n      return undefined\n  }\n}\n\nfunction cacheTypeForPayload(payload) {\n  switch (payload.method) {\n    // cache permanently\n    case 'web3_clientVersion':\n    case 'web3_sha3':\n    case 'eth_protocolVersion':\n    case 'eth_getBlockTransactionCountByHash':\n    case 'eth_getUncleCountByBlockHash':\n    case 'eth_getCode':\n    case 'eth_getBlockByHash':\n    case 'eth_getTransactionByHash':\n    case 'eth_getTransactionByBlockHashAndIndex':\n    case 'eth_getTransactionReceipt':\n    case 'eth_getUncleByBlockHashAndIndex':\n    case 'eth_getCompilers':\n    case 'eth_compileLLL':\n    case 'eth_compileSolidity':\n    case 'eth_compileSerpent':\n    case 'shh_version':\n      return 'perma'\n\n    // cache until fork\n    case 'eth_getBlockByNumber':\n    case 'eth_getBlockTransactionCountByNumber':\n    case 'eth_getUncleCountByBlockNumber':\n    case 'eth_getTransactionByBlockNumberAndIndex':\n    case 'eth_getUncleByBlockNumberAndIndex':\n      return 'fork'\n\n    // cache for block\n    case 'eth_gasPrice':\n    case 'eth_getBalance':\n    case 'eth_getStorageAt':\n    case 'eth_getTransactionCount':\n    case 'eth_call':\n    case 'eth_estimateGas':\n    case 'eth_getFilterLogs':\n    case 'eth_getLogs':\n    case 'eth_blockNumber':\n      return 'block'\n\n    // never cache\n    case 'net_version':\n    case 'net_peerCount':\n    case 'net_listening':\n    case 'eth_syncing':\n    case 'eth_sign':\n    case 'eth_coinbase':\n    case 'eth_mining':\n    case 'eth_hashrate':\n    case 'eth_accounts':\n    case 'eth_sendTransaction':\n    case 'eth_sendRawTransaction':\n    case 'eth_newFilter':\n    case 'eth_newBlockFilter':\n    case 'eth_newPendingTransactionFilter':\n    case 'eth_uninstallFilter':\n    case 'eth_getFilterChanges':\n    case 'eth_getWork':\n    case 'eth_submitWork':\n    case 'eth_submitHashrate':\n    case 'db_putString':\n    case 'db_getString':\n    case 'db_putHex':\n    case 'db_getHex':\n    case 'shh_post':\n    case 'shh_newIdentity':\n    case 'shh_hasIdentity':\n    case 'shh_newGroup':\n    case 'shh_addToGroup':\n    case 'shh_newFilter':\n    case 'shh_uninstallFilter':\n    case 'shh_getFilterChanges':\n    case 'shh_getMessages':\n      return 'never'\n  }\n}\n\n\n/***/ }),\n\n/***/ \"jYfc\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"ls82\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _onboard_50f68ab4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"D0PL\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"kB5k\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var bnc_sdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"/TMw\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"M39V\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(bowser__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var web3_provider_engine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"f4g2\");\n/* harmony import */ var web3_provider_engine__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(web3_provider_engine__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var web3_provider_engine_subproviders_rpc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"WPTD\");\n/* harmony import */ var web3_provider_engine_subproviders_rpc__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(web3_provider_engine_subproviders_rpc__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var web3_provider_engine_subproviders_hooked_wallet__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"Rlsf\");\n/* harmony import */ var web3_provider_engine_subproviders_hooked_wallet__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(web3_provider_engine_subproviders_hooked_wallet__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var web3_provider_engine_subproviders_subscriptions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"EqmL\");\n/* harmony import */ var web3_provider_engine_subproviders_subscriptions__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(web3_provider_engine_subproviders_subscriptions__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var web3_provider_engine_subproviders_filters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"cC/c\");\n/* harmony import */ var web3_provider_engine_subproviders_filters__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(web3_provider_engine_subproviders_filters__WEBPACK_IMPORTED_MODULE_9__);\n\n\n\n\n\n\n\n\n\n\n\nfunction createProvider(config) {\n  var getAccounts = config.getAccounts,\n      signTransaction = config.signTransaction,\n      rpcUrl = config.rpcUrl,\n      processMessage = config.processMessage,\n      processPersonalMessage = config.processPersonalMessage,\n      signMessage = config.signMessage,\n      signPersonalMessage = config.signPersonalMessage,\n      signTypedMessage = config.signTypedMessage;\n  var pollingInterval = Object(_onboard_50f68ab4_js__WEBPACK_IMPORTED_MODULE_1__[/* g */ \"i\"])(_onboard_50f68ab4_js__WEBPACK_IMPORTED_MODULE_1__[/* a */ \"c\"]).blockPollingInterval;\n  var idMgmt = getAccounts && new web3_provider_engine_subproviders_hooked_wallet__WEBPACK_IMPORTED_MODULE_7___default.a({\n    getAccounts: getAccounts,\n    signTransaction: signTransaction,\n    processMessage: processMessage,\n    processPersonalMessage: processPersonalMessage,\n    signMessage: signMessage,\n    signPersonalMessage: signPersonalMessage,\n    signTypedMessage: signTypedMessage\n  });\n  var rpcSubProvider = new web3_provider_engine_subproviders_rpc__WEBPACK_IMPORTED_MODULE_6___default.a({\n    rpcUrl: rpcUrl.includes('http') ? rpcUrl : \"https://\".concat(rpcUrl)\n  });\n  var provider = new web3_provider_engine__WEBPACK_IMPORTED_MODULE_5___default.a({\n    pollingInterval: pollingInterval\n  });\n  provider.addProvider(new web3_provider_engine_subproviders_subscriptions__WEBPACK_IMPORTED_MODULE_8___default.a());\n  provider.addProvider(new web3_provider_engine_subproviders_filters__WEBPACK_IMPORTED_MODULE_9___default.a());\n  idMgmt && provider.addProvider(idMgmt);\n  provider.addProvider(rpcSubProvider);\n  provider.start();\n  provider.on('error', console.error);\n  return provider;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createProvider);\n\n/***/ }),\n\n/***/ \"ja2i\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst Subprovider = __webpack_require__(\"Uu7K\")\n\n// wraps a json-rpc-engine middleware in a subprovider interface\n\nclass JsonRpcEngineMiddlewareSubprovider extends Subprovider {\n\n  // take a constructorFn to call once we have a reference to the engine\n  constructor (constructorFn) {\n    super()\n    if (!constructorFn) throw new Error('JsonRpcEngineMiddlewareSubprovider - no constructorFn specified')\n    this._constructorFn = constructorFn\n  }\n\n  // this is called once the subprovider has been added to the provider engine\n  setEngine (engine) {\n    if (this.middleware) throw new Error('JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice')\n    const blockTracker = engine._blockTracker\n    const middleware = this._constructorFn({ engine, provider: engine, blockTracker })\n    if (!middleware) throw new Error('JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware')\n    if (typeof middleware !== 'function') throw new Error('JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function')\n    this.middleware = middleware\n  }\n\n  handleRequest (req, provEngNext, provEngEnd) {\n    const res = { id: req.id }\n    this.middleware(req, res, middlewareNext, middlewareEnd)\n\n    function middlewareNext (handler) {\n      provEngNext((err, result, cb) => {\n        // update response object with result or error\n        if (err) {\n          delete res.result\n          res.error = { message: err.message || err }\n        } else {\n          res.result = result\n        }\n        // call middleware's next handler (even if error)\n        if (handler) {\n          handler(cb)\n        } else {\n          cb()\n        }\n      })\n    }\n\n    function middlewareEnd (err) {\n      if (err) return provEngEnd(err)\n      provEngEnd(null, res.result)\n    }\n  }\n\n}\n\nmodule.exports = JsonRpcEngineMiddlewareSubprovider\n\n\n/***/ }),\n\n/***/ \"kzD/\":\n/***/ (function(module, exports) {\n\nmodule.exports = createRandomId\n\n\nfunction createRandomId () {\n  // random id\n  return Math.floor(Number.MAX_SAFE_INTEGER * Math.random())\n}\n\n/***/ }),\n\n/***/ \"vgmO\":\n/***/ (function(module, exports) {\n\nvar win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n\n/***/ }),\n\n/***/ \"xQaN\":\n/***/ (function(module, exports, __webpack_require__) {\n\nconst getRandomId = __webpack_require__(\"kzD/\")\nconst extend = __webpack_require__(\"U6jy\")\n\nmodule.exports = createPayload\n\n\nfunction createPayload(data){\n  return extend({\n    // defaults\n    id: getRandomId(),\n    jsonrpc: '2.0',\n    params: [],\n    // user-specified\n  }, data)\n}\n\n\n/***/ })\n\n}]);","inputSourceMap":null}