{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{\"0IaG\":function(t,e,i){\"use strict\";i.d(e,\"a\",function(){return F});var n=i(\"rDax\"),a=i(\"+rOU\"),o=i(\"fXoL\"),s=i(\"FKr1\"),r=i(\"cH1L\"),l=i(\"ofXK\"),c=i(\"XNiG\"),h=i(\"NXyV\"),d=i(\"LRne\"),u=i(\"pLZG\"),p=i(\"IzEk\"),_=i(\"JX91\"),g=i(\"R0Ic\"),f=i(\"FtGj\"),m=i(\"u47x\");function b(t,e){}class v{constructor(){this.role=\"dialog\",this.panelClass=\"\",this.hasBackdrop=!0,this.backdropClass=\"\",this.disableClose=!1,this.width=\"\",this.height=\"\",this.maxWidth=\"80vw\",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.autoFocus=!0,this.restoreFocus=!0,this.closeOnNavigation=!0}}const y={dialogContainer:Object(g.j)(\"dialogContainer\",[Object(g.g)(\"void, exit\",Object(g.h)({opacity:0,transform:\"scale(0.7)\"})),Object(g.g)(\"enter\",Object(g.h)({transform:\"none\"})),Object(g.i)(\"* => enter\",Object(g.e)(\"150ms cubic-bezier(0, 0, 0.2, 1)\",Object(g.h)({transform:\"none\",opacity:1}))),Object(g.i)(\"* => void, * => exit\",Object(g.e)(\"75ms cubic-bezier(0.4, 0.0, 0.2, 1)\",Object(g.h)({opacity:0})))])};let C=(()=>{class t extends a.a{constructor(t,e,i,n,a,s){super(),this._elementRef=t,this._focusTrapFactory=e,this._changeDetectorRef=i,this._config=a,this._focusMonitor=s,this._animationStateChanged=new o.EventEmitter,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this.attachDomPortal=t=>(this._portalOutlet.hasAttached(),this._portalOutlet.attachDomPortal(t)),this._ariaLabelledBy=a.ariaLabelledBy||null,this._document=n}_initializeWithAttachedContent(){this._setupFocusTrap(),this._capturePreviouslyFocusedElement(),this._focusDialogContainer()}attachComponentPortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachComponentPortal(t)}attachTemplatePortal(t){return this._portalOutlet.hasAttached(),this._portalOutlet.attachTemplatePortal(t)}_recaptureFocus(){this._containsFocus()||(!this._config.autoFocus||!this._focusTrap.focusInitialElement())&&this._elementRef.nativeElement.focus()}_trapFocus(){this._config.autoFocus?this._focusTrap.focusInitialElementWhenReady():this._containsFocus()||this._elementRef.nativeElement.focus()}_restoreFocus(){const t=this._elementFocusedBeforeDialogWasOpened;if(this._config.restoreFocus&&t&&\"function\"==typeof t.focus){const e=this._getActiveElement(),i=this._elementRef.nativeElement;e&&e!==this._document.body&&e!==i&&!i.contains(e)||(this._focusMonitor?(this._focusMonitor.focusVia(t,this._closeInteractionType),this._closeInteractionType=null):t.focus())}this._focusTrap&&this._focusTrap.destroy()}_setupFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement)}_capturePreviouslyFocusedElement(){this._document&&(this._elementFocusedBeforeDialogWasOpened=this._getActiveElement())}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const t=this._elementRef.nativeElement,e=this._getActiveElement();return t===e||t.contains(e)}_getActiveElement(){var t;const e=this._document.activeElement;return(null===(t=null==e?void 0:e.shadowRoot)||void 0===t?void 0:t.activeElement)||e}}return t.\\u0275fac=function(e){return new(e||t)(o[\"\\u0275\\u0275directiveInject\"](o.ElementRef),o[\"\\u0275\\u0275directiveInject\"](m.b),o[\"\\u0275\\u0275directiveInject\"](o.ChangeDetectorRef),o[\"\\u0275\\u0275directiveInject\"](l.DOCUMENT,8),o[\"\\u0275\\u0275directiveInject\"](v),o[\"\\u0275\\u0275directiveInject\"](m.a))},t.\\u0275dir=o[\"\\u0275\\u0275defineDirective\"]({type:t,viewQuery:function(t,e){if(1&t&&o[\"\\u0275\\u0275staticViewQuery\"](a.b,!0),2&t){let t;o[\"\\u0275\\u0275queryRefresh\"](t=o[\"\\u0275\\u0275loadQuery\"]())&&(e._portalOutlet=t.first)}},features:[o[\"\\u0275\\u0275InheritDefinitionFeature\"]]}),t})(),j=(()=>{class t extends C{constructor(){super(...arguments),this._state=\"enter\"}_onAnimationDone({toState:t,totalTime:e}){\"enter\"===t?(this._trapFocus(),this._animationStateChanged.next({state:\"opened\",totalTime:e})):\"exit\"===t&&(this._restoreFocus(),this._animationStateChanged.next({state:\"closed\",totalTime:e}))}_onAnimationStart({toState:t,totalTime:e}){\"enter\"===t?this._animationStateChanged.next({state:\"opening\",totalTime:e}):\"exit\"!==t&&\"void\"!==t||this._animationStateChanged.next({state:\"closing\",totalTime:e})}_startExitAnimation(){this._state=\"exit\",this._changeDetectorRef.markForCheck()}}return t.\\u0275fac=function(e){return D(e||t)},t.\\u0275cmp=o[\"\\u0275\\u0275defineComponent\"]({type:t,selectors:[[\"mat-dialog-container\"]],hostAttrs:[\"tabindex\",\"-1\",\"aria-modal\",\"true\",1,\"mat-dialog-container\"],hostVars:6,hostBindings:function(t,e){1&t&&o[\"\\u0275\\u0275syntheticHostListener\"](\"@dialogContainer.start\",function(t){return e._onAnimationStart(t)})(\"@dialogContainer.done\",function(t){return e._onAnimationDone(t)}),2&t&&(o[\"\\u0275\\u0275hostProperty\"](\"id\",e._id),o[\"\\u0275\\u0275attribute\"](\"role\",e._config.role)(\"aria-labelledby\",e._config.ariaLabel?null:e._ariaLabelledBy)(\"aria-label\",e._config.ariaLabel)(\"aria-describedby\",e._config.ariaDescribedBy||null),o[\"\\u0275\\u0275syntheticHostProperty\"](\"@dialogContainer\",e._state))},features:[o[\"\\u0275\\u0275InheritDefinitionFeature\"]],decls:1,vars:0,consts:[[\"cdkPortalOutlet\",\"\"]],template:function(t,e){1&t&&o[\"\\u0275\\u0275template\"](0,b,0,0,\"ng-template\",0)},directives:[a.b],styles:[\".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\\n\"],encapsulation:2,data:{animation:[y.dialogContainer]}}),t})();const D=o[\"\\u0275\\u0275getInheritedFactory\"](j);let O=0;class T{constructor(t,e,i=\"mat-dialog-\"+O++){this._overlayRef=t,this._containerInstance=e,this.id=i,this.disableClose=this._containerInstance._config.disableClose,this._afterOpened=new c.a,this._afterClosed=new c.a,this._beforeClosed=new c.a,this._state=0,e._id=i,e._animationStateChanged.pipe(Object(u.a)(t=>\"opened\"===t.state),Object(p.a)(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),e._animationStateChanged.pipe(Object(u.a)(t=>\"closed\"===t.state),Object(p.a)(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),t.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._afterClosed.next(this._result),this._afterClosed.complete(),this.componentInstance=null,this._overlayRef.dispose()}),t.keydownEvents().pipe(Object(u.a)(t=>t.keyCode===f.e&&!this.disableClose&&!Object(f.o)(t))).subscribe(t=>{t.preventDefault(),I(this,\"keyboard\")}),t.backdropClick().subscribe(()=>{this.disableClose?this._containerInstance._recaptureFocus():I(this,\"mouse\")})}close(t){this._result=t,this._containerInstance._animationStateChanged.pipe(Object(u.a)(t=>\"closing\"===t.state),Object(p.a)(1)).subscribe(e=>{this._beforeClosed.next(t),this._beforeClosed.complete(),this._overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),e.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._afterClosed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._overlayRef.backdropClick()}keydownEvents(){return this._overlayRef.keydownEvents()}updatePosition(t){let e=this._getPositionStrategy();return t&&(t.left||t.right)?t.left?e.left(t.left):e.right(t.right):e.centerHorizontally(),t&&(t.top||t.bottom)?t.top?e.top(t.top):e.bottom(t.bottom):e.centerVertically(),this._overlayRef.updatePosition(),this}updateSize(t=\"\",e=\"\"){return this._overlayRef.updateSize({width:t,height:e}),this._overlayRef.updatePosition(),this}addPanelClass(t){return this._overlayRef.addPanelClass(t),this}removePanelClass(t){return this._overlayRef.removePanelClass(t),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._overlayRef.dispose()}_getPositionStrategy(){return this._overlayRef.getConfig().positionStrategy}}function I(t,e,i){return void 0!==t._containerInstance&&(t._containerInstance._closeInteractionType=e),t.close(i)}const w=new o.InjectionToken(\"MatDialogData\"),x=new o.InjectionToken(\"mat-dialog-default-options\"),A=new o.InjectionToken(\"mat-dialog-scroll-strategy\"),R={provide:A,deps:[n.a],useFactory:function(t){return()=>t.scrollStrategies.block()}};let k=(()=>{class t{constructor(t,e,i,n,a,o,s,r,l){this._overlay=t,this._injector=e,this._defaultOptions=i,this._parentDialog=n,this._overlayContainer=a,this._dialogRefConstructor=s,this._dialogContainerType=r,this._dialogDataToken=l,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new c.a,this._afterOpenedAtThisLevel=new c.a,this._ariaHiddenElements=new Map,this.afterAllClosed=Object(h.a)(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(Object(_.a)(void 0))),this._scrollStrategy=o}get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const t=this._parentDialog;return t?t._getAfterAllClosed():this._afterAllClosedAtThisLevel}open(t,e){(e=function(t,e){return Object.assign(Object.assign({},e),t)}(e,this._defaultOptions||new v)).id&&this.getDialogById(e.id);const i=this._createOverlay(e),n=this._attachDialogContainer(i,e),a=this._attachDialogContent(t,n,i,e);return this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(a),a.afterClosed().subscribe(()=>this._removeOpenDialog(a)),this.afterOpened.next(a),n._initializeWithAttachedContent(),a}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(t){return this.openDialogs.find(e=>e.id===t)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_createOverlay(t){const e=this._getOverlayConfig(t);return this._overlay.create(e)}_getOverlayConfig(t){const e=new n.b({positionStrategy:this._overlay.position().global(),scrollStrategy:t.scrollStrategy||this._scrollStrategy(),panelClass:t.panelClass,hasBackdrop:t.hasBackdrop,direction:t.direction,minWidth:t.minWidth,minHeight:t.minHeight,maxWidth:t.maxWidth,maxHeight:t.maxHeight,disposeOnNavigation:t.closeOnNavigation});return t.backdropClass&&(e.backdropClass=t.backdropClass),e}_attachDialogContainer(t,e){const i=o.Injector.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:v,useValue:e}]}),n=new a.c(this._dialogContainerType,e.viewContainerRef,i,e.componentFactoryResolver);return t.attach(n).instance}_attachDialogContent(t,e,i,n){const s=new this._dialogRefConstructor(i,e,n.id);if(t instanceof o.TemplateRef)e.attachTemplatePortal(new a.f(t,null,{$implicit:n.data,dialogRef:s}));else{const i=this._createInjector(n,s,e),o=e.attachComponentPortal(new a.c(t,n.viewContainerRef,i));s.componentInstance=o.instance}return s.updateSize(n.width,n.height).updatePosition(n.position),s}_createInjector(t,e,i){const n=t&&t.viewContainerRef&&t.viewContainerRef.injector,a=[{provide:this._dialogContainerType,useValue:i},{provide:this._dialogDataToken,useValue:t.data},{provide:this._dialogRefConstructor,useValue:e}];return!t.direction||n&&n.get(r.b,null)||a.push({provide:r.b,useValue:{value:t.direction,change:Object(d.a)()}}),o.Injector.create({parent:n||this._injector,providers:a})}_removeOpenDialog(t){const e=this.openDialogs.indexOf(t);e>-1&&(this.openDialogs.splice(e,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((t,e)=>{t?e.setAttribute(\"aria-hidden\",t):e.removeAttribute(\"aria-hidden\")}),this._ariaHiddenElements.clear(),this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const t=this._overlayContainer.getContainerElement();if(t.parentElement){const e=t.parentElement.children;for(let i=e.length-1;i>-1;i--){let n=e[i];n===t||\"SCRIPT\"===n.nodeName||\"STYLE\"===n.nodeName||n.hasAttribute(\"aria-live\")||(this._ariaHiddenElements.set(n,n.getAttribute(\"aria-hidden\")),n.setAttribute(\"aria-hidden\",\"true\"))}}}_closeDialogs(t){let e=t.length;for(;e--;)t[e].close()}}return t.\\u0275fac=function(e){return new(e||t)(o[\"\\u0275\\u0275directiveInject\"](n.a),o[\"\\u0275\\u0275directiveInject\"](o.Injector),o[\"\\u0275\\u0275directiveInject\"](void 0),o[\"\\u0275\\u0275directiveInject\"](void 0),o[\"\\u0275\\u0275directiveInject\"](n.c),o[\"\\u0275\\u0275directiveInject\"](void 0),o[\"\\u0275\\u0275directiveInject\"](o.Type),o[\"\\u0275\\u0275directiveInject\"](o.Type),o[\"\\u0275\\u0275directiveInject\"](o.InjectionToken))},t.\\u0275dir=o[\"\\u0275\\u0275defineDirective\"]({type:t}),t})(),E=(()=>{class t extends k{constructor(t,e,i,n,a,o,s){super(t,e,n,o,s,a,T,j,w)}}return t.\\u0275fac=function(e){return new(e||t)(o[\"\\u0275\\u0275inject\"](n.a),o[\"\\u0275\\u0275inject\"](o.Injector),o[\"\\u0275\\u0275inject\"](l.Location,8),o[\"\\u0275\\u0275inject\"](x,8),o[\"\\u0275\\u0275inject\"](A),o[\"\\u0275\\u0275inject\"](t,12),o[\"\\u0275\\u0275inject\"](n.c))},t.\\u0275prov=o[\"\\u0275\\u0275defineInjectable\"]({token:t,factory:t.\\u0275fac}),t})(),F=(()=>{class t{}return t.\\u0275mod=o[\"\\u0275\\u0275defineNgModule\"]({type:t}),t.\\u0275inj=o[\"\\u0275\\u0275defineInjector\"]({factory:function(e){return new(e||t)},providers:[E,R],imports:[[n.d,a.e,s.a],s.a]}),t})()}}]);","name":"16.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[16],{\n\n/***/ \"0IaG\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export MAT_DIALOG_DATA */\n/* unused harmony export MAT_DIALOG_DEFAULT_OPTIONS */\n/* unused harmony export MAT_DIALOG_SCROLL_STRATEGY */\n/* unused harmony export MAT_DIALOG_SCROLL_STRATEGY_FACTORY */\n/* unused harmony export MAT_DIALOG_SCROLL_STRATEGY_PROVIDER */\n/* unused harmony export MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY */\n/* unused harmony export MatDialog */\n/* unused harmony export MatDialogActions */\n/* unused harmony export MatDialogClose */\n/* unused harmony export MatDialogConfig */\n/* unused harmony export MatDialogContainer */\n/* unused harmony export MatDialogContent */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MatDialogModule; });\n/* unused harmony export MatDialogRef */\n/* unused harmony export MatDialogTitle */\n/* unused harmony export _MatDialogBase */\n/* unused harmony export _MatDialogContainerBase */\n/* unused harmony export _closeDialogVia */\n/* unused harmony export matDialogAnimations */\n/* unused harmony export throwMatDialogContentAlreadyAttachedError */\n/* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"rDax\");\n/* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"+rOU\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"FKr1\");\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"cH1L\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"ofXK\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"XNiG\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"NXyV\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"LRne\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"pLZG\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"IzEk\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(\"JX91\");\n/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(\"R0Ic\");\n/* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(\"FtGj\");\n/* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(\"u47x\");\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Configuration for opening a modal dialog with the MatDialog service.\n */\n\n\n\n\n\nfunction MatDialogContainer_ng_template_0_Template(rf, ctx) { }\nclass MatDialogConfig {\n    constructor() {\n        /** The ARIA role of the dialog element. */\n        this.role = 'dialog';\n        /** Custom class for the overlay pane. */\n        this.panelClass = '';\n        /** Whether the dialog has a backdrop. */\n        this.hasBackdrop = true;\n        /** Custom class for the backdrop. */\n        this.backdropClass = '';\n        /** Whether the user can use escape or clicking on the backdrop to close the modal. */\n        this.disableClose = false;\n        /** Width of the dialog. */\n        this.width = '';\n        /** Height of the dialog. */\n        this.height = '';\n        /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */\n        this.maxWidth = '80vw';\n        /** Data being injected into the child component. */\n        this.data = null;\n        /** ID of the element that describes the dialog. */\n        this.ariaDescribedBy = null;\n        /** ID of the element that labels the dialog. */\n        this.ariaLabelledBy = null;\n        /** Aria label to assign to the dialog element. */\n        this.ariaLabel = null;\n        /** Whether the dialog should focus the first focusable element on open. */\n        this.autoFocus = true;\n        /**\n         * Whether the dialog should restore focus to the\n         * previously-focused element, after it's closed.\n         */\n        this.restoreFocus = true;\n        /**\n         * Whether the dialog should close when the user goes backwards/forwards in history.\n         * Note that this usually doesn't include clicking on links (unless the user is using\n         * the `HashLocationStrategy`).\n         */\n        this.closeOnNavigation = true;\n        // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Animations used by MatDialog.\n * @docs-private\n */\nconst matDialogAnimations = {\n    /** Animation that is applied on the dialog container by default. */\n    dialogContainer: /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* trigger */ \"j\"])('dialogContainer', [\n        // Note: The `enter` animation transitions to `transform: none`, because for some reason\n        // specifying the transform explicitly, causes IE both to blur the dialog content and\n        // decimate the animation performance. Leaving it as `none` solves both issues.\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* state */ \"g\"])('void, exit', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* style */ \"h\"])({ opacity: 0, transform: 'scale(0.7)' })),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* state */ \"g\"])('enter', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* style */ \"h\"])({ transform: 'none' })),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* transition */ \"i\"])('* => enter', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* animate */ \"e\"])('150ms cubic-bezier(0, 0, 0.2, 1)', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* style */ \"h\"])({ transform: 'none', opacity: 1 }))),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* transition */ \"i\"])('* => void, * => exit', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* animate */ \"e\"])('75ms cubic-bezier(0.4, 0.0, 0.2, 1)', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_12__[/* style */ \"h\"])({ opacity: 0 }))),\n    ])\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Throws an exception for the case when a ComponentPortal is\n * attached to a DomPortalOutlet without an origin.\n * @docs-private\n */\nfunction throwMatDialogContentAlreadyAttachedError() {\n    throw Error('Attempting to attach dialog content after content is already attached');\n}\nlet _MatDialogContainerBase = /*@__PURE__*/ (() => {\n    class _MatDialogContainerBase extends _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__[/* BasePortalOutlet */ \"a\"] {\n        constructor(_elementRef, _focusTrapFactory, _changeDetectorRef, _document, \n        /** The dialog configuration. */\n        _config, _focusMonitor) {\n            super();\n            this._elementRef = _elementRef;\n            this._focusTrapFactory = _focusTrapFactory;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._config = _config;\n            this._focusMonitor = _focusMonitor;\n            /** Emits when an animation state changes. */\n            this._animationStateChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"EventEmitter\"]();\n            /** Element that was focused before the dialog was opened. Save this to restore upon close. */\n            this._elementFocusedBeforeDialogWasOpened = null;\n            /**\n             * Type of interaction that led to the dialog being closed. This is used to determine\n             * whether the focus style will be applied when returning focus to its original location\n             * after the dialog is closed.\n             */\n            this._closeInteractionType = null;\n            /**\n             * Attaches a DOM portal to the dialog container.\n             * @param portal Portal to be attached.\n             * @deprecated To be turned into a method.\n             * @breaking-change 10.0.0\n             */\n            this.attachDomPortal = (portal) => {\n                if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throwMatDialogContentAlreadyAttachedError();\n                }\n                return this._portalOutlet.attachDomPortal(portal);\n            };\n            this._ariaLabelledBy = _config.ariaLabelledBy || null;\n            this._document = _document;\n        }\n        /** Initializes the dialog container with the attached content. */\n        _initializeWithAttachedContent() {\n            this._setupFocusTrap();\n            // Save the previously focused element. This element will be re-focused\n            // when the dialog closes.\n            this._capturePreviouslyFocusedElement();\n            // Move focus onto the dialog immediately in order to prevent the user\n            // from accidentally opening multiple dialogs at the same time.\n            this._focusDialogContainer();\n        }\n        /**\n         * Attach a ComponentPortal as content to this dialog container.\n         * @param portal Portal to be attached as the dialog content.\n         */\n        attachComponentPortal(portal) {\n            if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throwMatDialogContentAlreadyAttachedError();\n            }\n            return this._portalOutlet.attachComponentPortal(portal);\n        }\n        /**\n         * Attach a TemplatePortal as content to this dialog container.\n         * @param portal Portal to be attached as the dialog content.\n         */\n        attachTemplatePortal(portal) {\n            if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throwMatDialogContentAlreadyAttachedError();\n            }\n            return this._portalOutlet.attachTemplatePortal(portal);\n        }\n        /** Moves focus back into the dialog if it was moved out. */\n        _recaptureFocus() {\n            if (!this._containsFocus()) {\n                const focusContainer = !this._config.autoFocus || !this._focusTrap.focusInitialElement();\n                if (focusContainer) {\n                    this._elementRef.nativeElement.focus();\n                }\n            }\n        }\n        /** Moves the focus inside the focus trap. */\n        _trapFocus() {\n            // If we were to attempt to focus immediately, then the content of the dialog would not yet be\n            // ready in instances where change detection has to run first. To deal with this, we simply\n            // wait for the microtask queue to be empty.\n            if (this._config.autoFocus) {\n                this._focusTrap.focusInitialElementWhenReady();\n            }\n            else if (!this._containsFocus()) {\n                // Otherwise ensure that focus is on the dialog container. It's possible that a different\n                // component tried to move focus while the open animation was running. See:\n                // https://github.com/angular/components/issues/16215. Note that we only want to do this\n                // if the focus isn't inside the dialog already, because it's possible that the consumer\n                // turned off `autoFocus` in order to move focus themselves.\n                this._elementRef.nativeElement.focus();\n            }\n        }\n        /** Restores focus to the element that was focused before the dialog opened. */\n        _restoreFocus() {\n            const previousElement = this._elementFocusedBeforeDialogWasOpened;\n            // We need the extra check, because IE can set the `activeElement` to null in some cases.\n            if (this._config.restoreFocus && previousElement &&\n                typeof previousElement.focus === 'function') {\n                const activeElement = this._getActiveElement();\n                const element = this._elementRef.nativeElement;\n                // Make sure that focus is still inside the dialog or is on the body (usually because a\n                // non-focusable element like the backdrop was clicked) before moving it. It's possible that\n                // the consumer moved it themselves before the animation was done, in which case we shouldn't\n                // do anything.\n                if (!activeElement || activeElement === this._document.body || activeElement === element ||\n                    element.contains(activeElement)) {\n                    if (this._focusMonitor) {\n                        this._focusMonitor.focusVia(previousElement, this._closeInteractionType);\n                        this._closeInteractionType = null;\n                    }\n                    else {\n                        previousElement.focus();\n                    }\n                }\n            }\n            if (this._focusTrap) {\n                this._focusTrap.destroy();\n            }\n        }\n        /** Sets up the focus trap. */\n        _setupFocusTrap() {\n            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n        }\n        /** Captures the element that was focused before the dialog was opened. */\n        _capturePreviouslyFocusedElement() {\n            if (this._document) {\n                this._elementFocusedBeforeDialogWasOpened = this._getActiveElement();\n            }\n        }\n        /** Focuses the dialog container. */\n        _focusDialogContainer() {\n            // Note that there is no focus method when rendering on the server.\n            if (this._elementRef.nativeElement.focus) {\n                this._elementRef.nativeElement.focus();\n            }\n        }\n        /** Returns whether focus is inside the dialog. */\n        _containsFocus() {\n            const element = this._elementRef.nativeElement;\n            const activeElement = this._getActiveElement();\n            return element === activeElement || element.contains(activeElement);\n        }\n        /** Gets the currently-focused element on the page. */\n        _getActiveElement() {\n            var _a;\n            // If the `activeElement` is inside a shadow root, `document.activeElement` will\n            // point to the shadow root so we have to descend into it ourselves.\n            const activeElement = this._document.activeElement;\n            return ((_a = activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement) || activeElement;\n        }\n    }\n    _MatDialogContainerBase.ɵfac = function _MatDialogContainerBase_Factory(t) { return new (t || _MatDialogContainerBase)(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ElementRef\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__[/* FocusTrapFactory */ \"b\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ChangeDetectorRef\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_common__WEBPACK_IMPORTED_MODULE_5__[\"DOCUMENT\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](MatDialogConfig), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__[/* FocusMonitor */ \"a\"])); };\n    _MatDialogContainerBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineDirective\"]({ type: _MatDialogContainerBase, viewQuery: function _MatDialogContainerBase_Query(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵstaticViewQuery\"](_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__[/* CdkPortalOutlet */ \"b\"], true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵqueryRefresh\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵloadQuery\"]()) && (ctx._portalOutlet = _t.first);\n            }\n        }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵInheritDefinitionFeature\"]] });\n    return _MatDialogContainerBase;\n})();\nlet MatDialogContainer = /*@__PURE__*/ (() => {\n    class MatDialogContainer extends _MatDialogContainerBase {\n        constructor() {\n            super(...arguments);\n            /** State of the dialog animation. */\n            this._state = 'enter';\n        }\n        /** Callback, invoked whenever an animation on the host completes. */\n        _onAnimationDone({ toState, totalTime }) {\n            if (toState === 'enter') {\n                this._trapFocus();\n                this._animationStateChanged.next({ state: 'opened', totalTime });\n            }\n            else if (toState === 'exit') {\n                this._restoreFocus();\n                this._animationStateChanged.next({ state: 'closed', totalTime });\n            }\n        }\n        /** Callback, invoked when an animation on the host starts. */\n        _onAnimationStart({ toState, totalTime }) {\n            if (toState === 'enter') {\n                this._animationStateChanged.next({ state: 'opening', totalTime });\n            }\n            else if (toState === 'exit' || toState === 'void') {\n                this._animationStateChanged.next({ state: 'closing', totalTime });\n            }\n        }\n        /** Starts the dialog exit animation. */\n        _startExitAnimation() {\n            this._state = 'exit';\n            // Mark the container for check so it can react if the\n            // view container is using OnPush change detection.\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    MatDialogContainer.ɵfac = function MatDialogContainer_Factory(t) { return ɵMatDialogContainer_BaseFactory(t || MatDialogContainer); };\n    MatDialogContainer.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineComponent\"]({ type: MatDialogContainer, selectors: [[\"mat-dialog-container\"]], hostAttrs: [\"tabindex\", \"-1\", \"aria-modal\", \"true\", 1, \"mat-dialog-container\"], hostVars: 6, hostBindings: function MatDialogContainer_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵsyntheticHostListener\"](\"@dialogContainer.start\", function MatDialogContainer_animation_dialogContainer_start_HostBindingHandler($event) { return ctx._onAnimationStart($event); })(\"@dialogContainer.done\", function MatDialogContainer_animation_dialogContainer_done_HostBindingHandler($event) { return ctx._onAnimationDone($event); });\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵhostProperty\"](\"id\", ctx._id);\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵattribute\"](\"role\", ctx._config.role)(\"aria-labelledby\", ctx._config.ariaLabel ? null : ctx._ariaLabelledBy)(\"aria-label\", ctx._config.ariaLabel)(\"aria-describedby\", ctx._config.ariaDescribedBy || null);\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵsyntheticHostProperty\"](\"@dialogContainer\", ctx._state);\n            }\n        }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵInheritDefinitionFeature\"]], decls: 1, vars: 0, consts: [[\"cdkPortalOutlet\", \"\"]], template: function MatDialogContainer_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵtemplate\"](0, MatDialogContainer_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n            }\n        }, directives: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__[/* CdkPortalOutlet */ \"b\"]], styles: [\".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\\n\"], encapsulation: 2, data: { animation: [matDialogAnimations.dialogContainer] } });\n    return MatDialogContainer;\n})();\nconst ɵMatDialogContainer_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵgetInheritedFactory\"](MatDialogContainer);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(jelbourn): resizing\n// Counter for unique dialog ids.\nlet uniqueId = 0;\n/**\n * Reference to a dialog opened via the MatDialog service.\n */\nclass MatDialogRef {\n    constructor(_overlayRef, _containerInstance, id = `mat-dialog-${uniqueId++}`) {\n        this._overlayRef = _overlayRef;\n        this._containerInstance = _containerInstance;\n        this.id = id;\n        /** Whether the user is allowed to close the dialog. */\n        this.disableClose = this._containerInstance._config.disableClose;\n        /** Subject for notifying the user that the dialog has finished opening. */\n        this._afterOpened = new rxjs__WEBPACK_IMPORTED_MODULE_6__[/* Subject */ \"a\"]();\n        /** Subject for notifying the user that the dialog has finished closing. */\n        this._afterClosed = new rxjs__WEBPACK_IMPORTED_MODULE_6__[/* Subject */ \"a\"]();\n        /** Subject for notifying the user that the dialog has started closing. */\n        this._beforeClosed = new rxjs__WEBPACK_IMPORTED_MODULE_6__[/* Subject */ \"a\"]();\n        /** Current state of the dialog. */\n        this._state = 0 /* OPEN */;\n        // Pass the id along to the container.\n        _containerInstance._id = id;\n        // Emit when opening animation completes\n        _containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__[/* filter */ \"a\"])(event => event.state === 'opened'), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* take */ \"a\"])(1))\n            .subscribe(() => {\n            this._afterOpened.next();\n            this._afterOpened.complete();\n        });\n        // Dispose overlay when closing animation is complete\n        _containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__[/* filter */ \"a\"])(event => event.state === 'closed'), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* take */ \"a\"])(1)).subscribe(() => {\n            clearTimeout(this._closeFallbackTimeout);\n            this._finishDialogClose();\n        });\n        _overlayRef.detachments().subscribe(() => {\n            this._beforeClosed.next(this._result);\n            this._beforeClosed.complete();\n            this._afterClosed.next(this._result);\n            this._afterClosed.complete();\n            this.componentInstance = null;\n            this._overlayRef.dispose();\n        });\n        _overlayRef.keydownEvents()\n            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__[/* filter */ \"a\"])(event => {\n            return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* ESCAPE */ \"e\"] && !this.disableClose && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* hasModifierKey */ \"o\"])(event);\n        }))\n            .subscribe(event => {\n            event.preventDefault();\n            _closeDialogVia(this, 'keyboard');\n        });\n        _overlayRef.backdropClick().subscribe(() => {\n            if (this.disableClose) {\n                this._containerInstance._recaptureFocus();\n            }\n            else {\n                _closeDialogVia(this, 'mouse');\n            }\n        });\n    }\n    /**\n     * Close the dialog.\n     * @param dialogResult Optional result to return to the dialog opener.\n     */\n    close(dialogResult) {\n        this._result = dialogResult;\n        // Transition the backdrop in parallel to the dialog.\n        this._containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__[/* filter */ \"a\"])(event => event.state === 'closing'), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* take */ \"a\"])(1))\n            .subscribe(event => {\n            this._beforeClosed.next(dialogResult);\n            this._beforeClosed.complete();\n            this._overlayRef.detachBackdrop();\n            // The logic that disposes of the overlay depends on the exit animation completing, however\n            // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback\n            // timeout which will clean everything up if the animation hasn't fired within the specified\n            // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the\n            // vast majority of cases the timeout will have been cleared before it has the chance to fire.\n            this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), event.totalTime + 100);\n        });\n        this._state = 1 /* CLOSING */;\n        this._containerInstance._startExitAnimation();\n    }\n    /**\n     * Gets an observable that is notified when the dialog is finished opening.\n     */\n    afterOpened() {\n        return this._afterOpened;\n    }\n    /**\n     * Gets an observable that is notified when the dialog is finished closing.\n     */\n    afterClosed() {\n        return this._afterClosed;\n    }\n    /**\n     * Gets an observable that is notified when the dialog has started closing.\n     */\n    beforeClosed() {\n        return this._beforeClosed;\n    }\n    /**\n     * Gets an observable that emits when the overlay's backdrop has been clicked.\n     */\n    backdropClick() {\n        return this._overlayRef.backdropClick();\n    }\n    /**\n     * Gets an observable that emits when keydown events are targeted on the overlay.\n     */\n    keydownEvents() {\n        return this._overlayRef.keydownEvents();\n    }\n    /**\n     * Updates the dialog's position.\n     * @param position New dialog position.\n     */\n    updatePosition(position) {\n        let strategy = this._getPositionStrategy();\n        if (position && (position.left || position.right)) {\n            position.left ? strategy.left(position.left) : strategy.right(position.right);\n        }\n        else {\n            strategy.centerHorizontally();\n        }\n        if (position && (position.top || position.bottom)) {\n            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);\n        }\n        else {\n            strategy.centerVertically();\n        }\n        this._overlayRef.updatePosition();\n        return this;\n    }\n    /**\n     * Updates the dialog's width and height.\n     * @param width New width of the dialog.\n     * @param height New height of the dialog.\n     */\n    updateSize(width = '', height = '') {\n        this._overlayRef.updateSize({ width, height });\n        this._overlayRef.updatePosition();\n        return this;\n    }\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes) {\n        this._overlayRef.addPanelClass(classes);\n        return this;\n    }\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes) {\n        this._overlayRef.removePanelClass(classes);\n        return this;\n    }\n    /** Gets the current state of the dialog's lifecycle. */\n    getState() {\n        return this._state;\n    }\n    /**\n     * Finishes the dialog close by updating the state of the dialog\n     * and disposing the overlay.\n     */\n    _finishDialogClose() {\n        this._state = 2 /* CLOSED */;\n        this._overlayRef.dispose();\n    }\n    /** Fetches the position strategy object from the overlay ref. */\n    _getPositionStrategy() {\n        return this._overlayRef.getConfig().positionStrategy;\n    }\n}\n/**\n * Closes the dialog with the specified interaction type. This is currently not part of\n * `MatDialogRef` as that would conflict with custom dialog ref mocks provided in tests.\n * More details. See: https://github.com/angular/components/pull/9257#issuecomment-651342226.\n */\n// TODO: TODO: Move this back into `MatDialogRef` when we provide an official mock dialog ref.\nfunction _closeDialogVia(ref, interactionType, result) {\n    // Some mock dialog ref instances in tests do not have the `_containerInstance` property.\n    // For those, we keep the behavior as is and do not deal with the interaction type.\n    if (ref._containerInstance !== undefined) {\n        ref._containerInstance._closeInteractionType = interactionType;\n    }\n    return ref.close(result);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token that can be used to access the data that was passed in to a dialog. */\nconst MAT_DIALOG_DATA = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"InjectionToken\"]('MatDialogData');\n/** Injection token that can be used to specify default dialog options. */\nconst MAT_DIALOG_DEFAULT_OPTIONS = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"InjectionToken\"]('mat-dialog-default-options');\n/** Injection token that determines the scroll handling while the dialog is open. */\nconst MAT_DIALOG_SCROLL_STRATEGY = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"InjectionToken\"]('mat-dialog-scroll-strategy');\n/** @docs-private */\nfunction MAT_DIALOG_SCROLL_STRATEGY_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.block();\n}\n/** @docs-private */\nfunction MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.block();\n}\n/** @docs-private */\nconst MAT_DIALOG_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_DIALOG_SCROLL_STRATEGY,\n    deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* Overlay */ \"a\"]],\n    useFactory: MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\nlet _MatDialogBase = /*@__PURE__*/ (() => {\n    class _MatDialogBase {\n        constructor(_overlay, _injector, _defaultOptions, _parentDialog, _overlayContainer, scrollStrategy, _dialogRefConstructor, _dialogContainerType, _dialogDataToken) {\n            this._overlay = _overlay;\n            this._injector = _injector;\n            this._defaultOptions = _defaultOptions;\n            this._parentDialog = _parentDialog;\n            this._overlayContainer = _overlayContainer;\n            this._dialogRefConstructor = _dialogRefConstructor;\n            this._dialogContainerType = _dialogContainerType;\n            this._dialogDataToken = _dialogDataToken;\n            this._openDialogsAtThisLevel = [];\n            this._afterAllClosedAtThisLevel = new rxjs__WEBPACK_IMPORTED_MODULE_6__[/* Subject */ \"a\"]();\n            this._afterOpenedAtThisLevel = new rxjs__WEBPACK_IMPORTED_MODULE_6__[/* Subject */ \"a\"]();\n            this._ariaHiddenElements = new Map();\n            // TODO (jelbourn): tighten the typing right-hand side of this expression.\n            /**\n             * Stream that emits when all open dialog have finished closing.\n             * Will emit on subscribe if there are no open dialogs to begin with.\n             */\n            this.afterAllClosed = Object(rxjs__WEBPACK_IMPORTED_MODULE_7__[/* defer */ \"a\"])(() => this.openDialogs.length ?\n                this._getAfterAllClosed() :\n                this._getAfterAllClosed().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__[/* startWith */ \"a\"])(undefined)));\n            this._scrollStrategy = scrollStrategy;\n        }\n        /** Keeps track of the currently-open dialogs. */\n        get openDialogs() {\n            return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\n        }\n        /** Stream that emits when a dialog has been opened. */\n        get afterOpened() {\n            return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\n        }\n        _getAfterAllClosed() {\n            const parent = this._parentDialog;\n            return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;\n        }\n        open(componentOrTemplateRef, config) {\n            config = _applyConfigDefaults(config, this._defaultOptions || new MatDialogConfig());\n            if (config.id && this.getDialogById(config.id) &&\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error(`Dialog with id \"${config.id}\" exists already. The dialog id must be unique.`);\n            }\n            const overlayRef = this._createOverlay(config);\n            const dialogContainer = this._attachDialogContainer(overlayRef, config);\n            const dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);\n            // If this is the first dialog that we're opening, hide all the non-overlay content.\n            if (!this.openDialogs.length) {\n                this._hideNonDialogContentFromAssistiveTechnology();\n            }\n            this.openDialogs.push(dialogRef);\n            dialogRef.afterClosed().subscribe(() => this._removeOpenDialog(dialogRef));\n            this.afterOpened.next(dialogRef);\n            // Notify the dialog container that the content has been attached.\n            dialogContainer._initializeWithAttachedContent();\n            return dialogRef;\n        }\n        /**\n         * Closes all of the currently-open dialogs.\n         */\n        closeAll() {\n            this._closeDialogs(this.openDialogs);\n        }\n        /**\n         * Finds an open dialog by its id.\n         * @param id ID to use when looking up the dialog.\n         */\n        getDialogById(id) {\n            return this.openDialogs.find(dialog => dialog.id === id);\n        }\n        ngOnDestroy() {\n            // Only close the dialogs at this level on destroy\n            // since the parent service may still be active.\n            this._closeDialogs(this._openDialogsAtThisLevel);\n            this._afterAllClosedAtThisLevel.complete();\n            this._afterOpenedAtThisLevel.complete();\n        }\n        /**\n         * Creates the overlay into which the dialog will be loaded.\n         * @param config The dialog configuration.\n         * @returns A promise resolving to the OverlayRef for the created overlay.\n         */\n        _createOverlay(config) {\n            const overlayConfig = this._getOverlayConfig(config);\n            return this._overlay.create(overlayConfig);\n        }\n        /**\n         * Creates an overlay config from a dialog config.\n         * @param dialogConfig The dialog configuration.\n         * @returns The overlay configuration.\n         */\n        _getOverlayConfig(dialogConfig) {\n            const state = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* OverlayConfig */ \"b\"]({\n                positionStrategy: this._overlay.position().global(),\n                scrollStrategy: dialogConfig.scrollStrategy || this._scrollStrategy(),\n                panelClass: dialogConfig.panelClass,\n                hasBackdrop: dialogConfig.hasBackdrop,\n                direction: dialogConfig.direction,\n                minWidth: dialogConfig.minWidth,\n                minHeight: dialogConfig.minHeight,\n                maxWidth: dialogConfig.maxWidth,\n                maxHeight: dialogConfig.maxHeight,\n                disposeOnNavigation: dialogConfig.closeOnNavigation\n            });\n            if (dialogConfig.backdropClass) {\n                state.backdropClass = dialogConfig.backdropClass;\n            }\n            return state;\n        }\n        /**\n         * Attaches a dialog container to a dialog's already-created overlay.\n         * @param overlay Reference to the dialog's underlying overlay.\n         * @param config The dialog configuration.\n         * @returns A promise resolving to a ComponentRef for the attached container.\n         */\n        _attachDialogContainer(overlay, config) {\n            const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n            const injector = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Injector\"].create({\n                parent: userInjector || this._injector,\n                providers: [{ provide: MatDialogConfig, useValue: config }]\n            });\n            const containerPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__[/* ComponentPortal */ \"c\"](this._dialogContainerType, config.viewContainerRef, injector, config.componentFactoryResolver);\n            const containerRef = overlay.attach(containerPortal);\n            return containerRef.instance;\n        }\n        /**\n         * Attaches the user-provided component to the already-created dialog container.\n         * @param componentOrTemplateRef The type of component being loaded into the dialog,\n         *     or a TemplateRef to instantiate as the content.\n         * @param dialogContainer Reference to the wrapping dialog container.\n         * @param overlayRef Reference to the overlay in which the dialog resides.\n         * @param config The dialog configuration.\n         * @returns A promise resolving to the MatDialogRef that should be returned to the user.\n         */\n        _attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config) {\n            // Create a reference to the dialog we're creating in order to give the user a handle\n            // to modify and close it.\n            const dialogRef = new this._dialogRefConstructor(overlayRef, dialogContainer, config.id);\n            if (componentOrTemplateRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"TemplateRef\"]) {\n                dialogContainer.attachTemplatePortal(new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__[/* TemplatePortal */ \"f\"](componentOrTemplateRef, null, { $implicit: config.data, dialogRef }));\n            }\n            else {\n                const injector = this._createInjector(config, dialogRef, dialogContainer);\n                const contentRef = dialogContainer.attachComponentPortal(new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__[/* ComponentPortal */ \"c\"](componentOrTemplateRef, config.viewContainerRef, injector));\n                dialogRef.componentInstance = contentRef.instance;\n            }\n            dialogRef\n                .updateSize(config.width, config.height)\n                .updatePosition(config.position);\n            return dialogRef;\n        }\n        /**\n         * Creates a custom injector to be used inside the dialog. This allows a component loaded inside\n         * of a dialog to close itself and, optionally, to return a value.\n         * @param config Config object that is used to construct the dialog.\n         * @param dialogRef Reference to the dialog.\n         * @param dialogContainer Dialog container element that wraps all of the contents.\n         * @returns The custom injector that can be used inside the dialog.\n         */\n        _createInjector(config, dialogRef, dialogContainer) {\n            const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n            // The dialog container should be provided as the dialog container and the dialog's\n            // content are created out of the same `ViewContainerRef` and as such, are siblings\n            // for injector purposes. To allow the hierarchy that is expected, the dialog\n            // container is explicitly provided in the injector.\n            const providers = [\n                { provide: this._dialogContainerType, useValue: dialogContainer },\n                { provide: this._dialogDataToken, useValue: config.data },\n                { provide: this._dialogRefConstructor, useValue: dialogRef }\n            ];\n            if (config.direction &&\n                (!userInjector || !userInjector.get(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__[/* Directionality */ \"b\"], null))) {\n                providers.push({\n                    provide: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__[/* Directionality */ \"b\"],\n                    useValue: { value: config.direction, change: Object(rxjs__WEBPACK_IMPORTED_MODULE_8__[/* of */ \"a\"])() }\n                });\n            }\n            return _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Injector\"].create({ parent: userInjector || this._injector, providers });\n        }\n        /**\n         * Removes a dialog from the array of open dialogs.\n         * @param dialogRef Dialog to be removed.\n         */\n        _removeOpenDialog(dialogRef) {\n            const index = this.openDialogs.indexOf(dialogRef);\n            if (index > -1) {\n                this.openDialogs.splice(index, 1);\n                // If all the dialogs were closed, remove/restore the `aria-hidden`\n                // to a the siblings and emit to the `afterAllClosed` stream.\n                if (!this.openDialogs.length) {\n                    this._ariaHiddenElements.forEach((previousValue, element) => {\n                        if (previousValue) {\n                            element.setAttribute('aria-hidden', previousValue);\n                        }\n                        else {\n                            element.removeAttribute('aria-hidden');\n                        }\n                    });\n                    this._ariaHiddenElements.clear();\n                    this._getAfterAllClosed().next();\n                }\n            }\n        }\n        /**\n         * Hides all of the content that isn't an overlay from assistive technology.\n         */\n        _hideNonDialogContentFromAssistiveTechnology() {\n            const overlayContainer = this._overlayContainer.getContainerElement();\n            // Ensure that the overlay container is attached to the DOM.\n            if (overlayContainer.parentElement) {\n                const siblings = overlayContainer.parentElement.children;\n                for (let i = siblings.length - 1; i > -1; i--) {\n                    let sibling = siblings[i];\n                    if (sibling !== overlayContainer &&\n                        sibling.nodeName !== 'SCRIPT' &&\n                        sibling.nodeName !== 'STYLE' &&\n                        !sibling.hasAttribute('aria-live')) {\n                        this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));\n                        sibling.setAttribute('aria-hidden', 'true');\n                    }\n                }\n            }\n        }\n        /** Closes all of the dialogs in an array. */\n        _closeDialogs(dialogs) {\n            let i = dialogs.length;\n            while (i--) {\n                // The `_openDialogs` property isn't updated after close until the rxjs subscription\n                // runs on the next microtask, in addition to modifying the array as we're going\n                // through it. We loop through all of them and call close without assuming that\n                // they'll be removed from the list instantaneously.\n                dialogs[i].close();\n            }\n        }\n    }\n    _MatDialogBase.ɵfac = function _MatDialogBase_Factory(t) { return new (t || _MatDialogBase)(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* Overlay */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Injector\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](undefined), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](undefined), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* OverlayContainer */ \"c\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](undefined), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Type\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Type\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"InjectionToken\"])); };\n    _MatDialogBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineDirective\"]({ type: _MatDialogBase });\n    return _MatDialogBase;\n})();\nlet MatDialog = /*@__PURE__*/ (() => {\n    class MatDialog extends _MatDialogBase {\n        constructor(overlay, injector, \n        /**\n         * @deprecated `_location` parameter to be removed.\n         * @breaking-change 10.0.0\n         */\n        location, defaultOptions, scrollStrategy, parentDialog, overlayContainer) {\n            super(overlay, injector, defaultOptions, parentDialog, overlayContainer, scrollStrategy, MatDialogRef, MatDialogContainer, MAT_DIALOG_DATA);\n        }\n    }\n    MatDialog.ɵfac = function MatDialog_Factory(t) { return new (t || MatDialog)(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* Overlay */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Injector\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"](_angular_common__WEBPACK_IMPORTED_MODULE_5__[\"Location\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"](MAT_DIALOG_DEFAULT_OPTIONS, 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"](MAT_DIALOG_SCROLL_STRATEGY), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"](MatDialog, 12), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* OverlayContainer */ \"c\"])); };\n    MatDialog.ɵprov = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineInjectable\"]({ token: MatDialog, factory: MatDialog.ɵfac });\n    return MatDialog;\n})();\n/**\n * Applies default options to the dialog config.\n * @param config Config to be modified.\n * @param defaultOptions Default options provided.\n * @returns The new configuration object.\n */\nfunction _applyConfigDefaults(config, defaultOptions) {\n    return Object.assign(Object.assign({}, defaultOptions), config);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Counter used to generate unique IDs for dialog elements. */\nlet dialogElementUid = 0;\nlet MatDialogClose = /*@__PURE__*/ (() => {\n    class MatDialogClose {\n        constructor(\n        // The dialog title directive is always used in combination with a `MatDialogRef`.\n        // tslint:disable-next-line: lightweight-tokens\n        dialogRef, _elementRef, _dialog) {\n            this.dialogRef = dialogRef;\n            this._elementRef = _elementRef;\n            this._dialog = _dialog;\n            /** Default to \"button\" to prevents accidental form submits. */\n            this.type = 'button';\n        }\n        ngOnInit() {\n            if (!this.dialogRef) {\n                // When this directive is included in a dialog via TemplateRef (rather than being\n                // in a Component), the DialogRef isn't available via injection because embedded\n                // views cannot be given a custom injector. Instead, we look up the DialogRef by\n                // ID. This must occur in `onInit`, as the ID binding for the dialog container won't\n                // be resolved at constructor time.\n                this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);\n            }\n        }\n        ngOnChanges(changes) {\n            const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];\n            if (proxiedChange) {\n                this.dialogResult = proxiedChange.currentValue;\n            }\n        }\n        _onButtonClick(event) {\n            // Determinate the focus origin using the click event, because using the FocusMonitor will\n            // result in incorrect origins. Most of the time, close buttons will be auto focused in the\n            // dialog, and therefore clicking the button won't result in a focus change. This means that\n            // the FocusMonitor won't detect any origin change, and will always output `program`.\n            _closeDialogVia(this.dialogRef, event.screenX === 0 && event.screenY === 0 ? 'keyboard' : 'mouse', this.dialogResult);\n        }\n    }\n    MatDialogClose.ɵfac = function MatDialogClose_Factory(t) { return new (t || MatDialogClose)(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](MatDialogRef, 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ElementRef\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](MatDialog)); };\n    MatDialogClose.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineDirective\"]({ type: MatDialogClose, selectors: [[\"\", \"mat-dialog-close\", \"\"], [\"\", \"matDialogClose\", \"\"]], hostVars: 2, hostBindings: function MatDialogClose_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵlistener\"](\"click\", function MatDialogClose_click_HostBindingHandler($event) { return ctx._onButtonClick($event); });\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵattribute\"](\"aria-label\", ctx.ariaLabel || null)(\"type\", ctx.type);\n            }\n        }, inputs: { type: \"type\", dialogResult: [\"mat-dialog-close\", \"dialogResult\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], _matDialogClose: [\"matDialogClose\", \"_matDialogClose\"] }, exportAs: [\"matDialogClose\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵNgOnChangesFeature\"]] });\n    return MatDialogClose;\n})();\nlet MatDialogTitle = /*@__PURE__*/ (() => {\n    class MatDialogTitle {\n        constructor(\n        // The dialog title directive is always used in combination with a `MatDialogRef`.\n        // tslint:disable-next-line: lightweight-tokens\n        _dialogRef, _elementRef, _dialog) {\n            this._dialogRef = _dialogRef;\n            this._elementRef = _elementRef;\n            this._dialog = _dialog;\n            this.id = `mat-dialog-title-${dialogElementUid++}`;\n        }\n        ngOnInit() {\n            if (!this._dialogRef) {\n                this._dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);\n            }\n            if (this._dialogRef) {\n                Promise.resolve().then(() => {\n                    const container = this._dialogRef._containerInstance;\n                    if (container && !container._ariaLabelledBy) {\n                        container._ariaLabelledBy = this.id;\n                    }\n                });\n            }\n        }\n    }\n    MatDialogTitle.ɵfac = function MatDialogTitle_Factory(t) { return new (t || MatDialogTitle)(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](MatDialogRef, 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ElementRef\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdirectiveInject\"](MatDialog)); };\n    MatDialogTitle.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineDirective\"]({ type: MatDialogTitle, selectors: [[\"\", \"mat-dialog-title\", \"\"], [\"\", \"matDialogTitle\", \"\"]], hostAttrs: [1, \"mat-dialog-title\"], hostVars: 1, hostBindings: function MatDialogTitle_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵhostProperty\"](\"id\", ctx.id);\n            }\n        }, inputs: { id: \"id\" }, exportAs: [\"matDialogTitle\"] });\n    return MatDialogTitle;\n})();\nlet MatDialogContent = /*@__PURE__*/ (() => {\n    class MatDialogContent {\n    }\n    MatDialogContent.ɵfac = function MatDialogContent_Factory(t) { return new (t || MatDialogContent)(); };\n    MatDialogContent.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineDirective\"]({ type: MatDialogContent, selectors: [[\"\", \"mat-dialog-content\", \"\"], [\"mat-dialog-content\"], [\"\", \"matDialogContent\", \"\"]], hostAttrs: [1, \"mat-dialog-content\"] });\n    return MatDialogContent;\n})();\nlet MatDialogActions = /*@__PURE__*/ (() => {\n    class MatDialogActions {\n    }\n    MatDialogActions.ɵfac = function MatDialogActions_Factory(t) { return new (t || MatDialogActions)(); };\n    MatDialogActions.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineDirective\"]({ type: MatDialogActions, selectors: [[\"\", \"mat-dialog-actions\", \"\"], [\"mat-dialog-actions\"], [\"\", \"matDialogActions\", \"\"]], hostAttrs: [1, \"mat-dialog-actions\"] });\n    return MatDialogActions;\n})();\n/**\n * Finds the closest MatDialogRef to an element by looking at the DOM.\n * @param element Element relative to which to look for a dialog.\n * @param openDialogs References to the currently-open dialogs.\n */\nfunction getClosestDialog(element, openDialogs) {\n    let parent = element.nativeElement.parentElement;\n    while (parent && !parent.classList.contains('mat-dialog-container')) {\n        parent = parent.parentElement;\n    }\n    return parent ? openDialogs.find(dialog => dialog.id === parent.id) : null;\n}\nlet MatDialogModule = /*@__PURE__*/ (() => {\n    class MatDialogModule {\n    }\n    MatDialogModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineNgModule\"]({ type: MatDialogModule });\n    MatDialogModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineInjector\"]({ factory: function MatDialogModule_Factory(t) { return new (t || MatDialogModule)(); }, providers: [\n            MatDialog,\n            MAT_DIALOG_SCROLL_STRATEGY_PROVIDER,\n        ], imports: [[\n                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* OverlayModule */ \"d\"],\n                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__[/* PortalModule */ \"e\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatCommonModule */ \"a\"],\n            ], _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatCommonModule */ \"a\"]] });\n    return MatDialogModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵsetNgModuleScope\"](MatDialogModule, { declarations: function () { return [MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogActions, MatDialogContent]; }, imports: function () {\n            return [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* OverlayModule */ \"d\"],\n                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__[/* PortalModule */ \"e\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatCommonModule */ \"a\"]];\n        }, exports: function () { return [MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogContent, MatDialogActions, _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatCommonModule */ \"a\"]]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=dialog.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}