{"version":3,"file":"base-eth-keyring.cjs.production.min.js","sources":["../src/BaseKeyring.ts"],"sourcesContent":["import HDKey from 'hdkey';\nimport { toChecksumAddress, publicToAddress, BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Transaction } from '@ethereumjs/tx';\nimport { DataType, EthSignRequest } from '@keystonehq/bc-ur-registry-eth';\nimport * as uuid from 'uuid';\nimport { InteractionProvider } from './InteractionProvider';\n\nconst keyringType = 'QR Hardware Wallet Device';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\n\nexport type StoredKeyring = {\n    xfp: string;\n    xpub: string;\n    hdPath: string;\n    accounts: string[];\n    currentAccount: number;\n    page: number;\n    perPage: number;\n    paths: Record<string, number>;\n};\n\nexport type PagedAccount = { address: string; balance: any; index: number };\n\nexport class BaseKeyring {\n    getInteraction = (): InteractionProvider => {\n        throw new Error(\n            '#ktek_error, method getInteraction not implemented, please extend BaseKeyring by overwriting this method.',\n        );\n    };\n    static type = keyringType;\n    protected xfp: string;\n    protected type = keyringType;\n    protected xpub: string;\n    protected hdPath: string;\n    protected accounts: string[];\n    protected currentAccount: number;\n    protected page: number;\n    protected perPage: number;\n    protected paths: Record<string, number>;\n    protected hdk: HDKey;\n    protected latestAccount: number;\n\n    constructor(opts?: StoredKeyring) {\n        this.xfp = '';\n        this.xpub = '';\n        this.hdPath = '';\n        this.page = 0;\n        this.perPage = 5;\n        this.accounts = [];\n        this.currentAccount = 0;\n        this.paths = {};\n        this.latestAccount = 0;\n        this.deserialize(opts);\n    }\n\n    private readKeyringCryptoHDKey = async (): Promise<{ xfp: string; xpub: string; hdPath: string }> => {\n        const cryptoHDKey = await this.getInteraction().readCryptoHDKey();\n        const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;\n        const xfp = cryptoHDKey.getOrigin().getSourceFingerprint()?.toString('hex');\n        if (!xfp) {\n            throw new Error('invalid crypto-hd-key, cannot get source fingerprint');\n        }\n        const xpub = cryptoHDKey.getBip32Key();\n        return {\n            xfp,\n            xpub,\n            hdPath,\n        };\n    };\n\n    protected requestSignature = async (\n        _requestId: string,\n        signRequest: EthSignRequest,\n        requestTitle?: string,\n        requestDescription?: string,\n    ): Promise<{ r: Buffer; s: Buffer; v: Buffer }> => {\n        const ethSignature = await this.getInteraction().requestSignature(\n            signRequest,\n            requestTitle,\n            requestDescription,\n        );\n        const requestIdBuffer = ethSignature.getRequestId();\n        const signature = ethSignature.getSignature();\n        if (requestIdBuffer) {\n            const requestId = uuid.stringify(requestIdBuffer);\n            if (requestId !== _requestId) {\n                throw new Error('read signature error: mismatched requestId');\n            }\n        }\n        const r = signature.slice(0, 32);\n        const s = signature.slice(32, 64);\n        const v = signature.slice(64);\n        return {\n            r,\n            s,\n            v,\n        };\n    };\n\n    async readKeyring(): Promise<void> {\n        const { xpub, xfp, hdPath } = await this.readKeyringCryptoHDKey();\n        this.xfp = xfp;\n        this.xpub = xpub;\n        this.hdPath = hdPath;\n    }\n\n    protected checkKeyring() {\n        if (!this.xfp || !this.xpub || !this.hdPath) {\n            throw new Error('keyring not fulfilled, please call function `readKeyring` firstly');\n        }\n    }\n\n    serialize(): Promise<StoredKeyring> {\n        return Promise.resolve({\n            xfp: this.xfp,\n            xpub: this.xpub,\n            hdPath: this.hdPath,\n            accounts: this.accounts,\n            currentAccount: this.currentAccount,\n            page: this.page,\n            perPage: this.perPage,\n            paths: this.paths,\n        });\n    }\n\n    deserialize(opts?: StoredKeyring): void {\n        if (opts) {\n            this.xfp = opts.xfp;\n            this.xpub = opts.xpub;\n            this.hdPath = opts.hdPath;\n            this.accounts = opts.accounts;\n            this.currentAccount = opts.currentAccount;\n            this.page = opts.page;\n            this.perPage = opts.perPage;\n            this.paths = opts.paths;\n        }\n    }\n\n    setCurrentAccount(index: number): void {\n        this.currentAccount = index;\n    }\n\n    getCurrentAccount(): number {\n        return this.currentAccount;\n    }\n\n    getCurrentAddress(): string {\n        return this.accounts[this.currentAccount];\n    }\n\n    addAccounts(n = 1): Promise<string[]> {\n        return new Promise((resolve, reject) => {\n            try {\n                const from = this.latestAccount;\n                const to = from + n;\n                const newAccounts = [];\n\n                for (let i = from; i < to; i++) {\n                    const address = this._addressFromIndex(pathBase, i);\n                    newAccounts.push(address);\n                    this.page = 0;\n                    this.latestAccount++;\n                }\n                this.accounts = this.accounts.concat(newAccounts);\n                resolve(this.accounts);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    getFirstPage(): Promise<PagedAccount[]> {\n        this.page = 0;\n        return this.__getPage(1);\n    }\n\n    getNextPage(): Promise<PagedAccount[]> {\n        return this.__getPage(1);\n    }\n\n    getPreviousPage(): Promise<PagedAccount[]> {\n        return this.__getPage(-1);\n    }\n\n    async __getPage(increment: number): Promise<PagedAccount[]> {\n        this.page += increment;\n\n        if (this.page <= 0) {\n            this.page = 1;\n        }\n\n        if (!!!this.xfp) {\n            await this.readKeyring();\n        }\n\n        return new Promise((resolve, reject) => {\n            try {\n                const from = (this.page - 1) * this.perPage;\n                const to = from + this.perPage;\n\n                const accounts = [];\n\n                for (let i = from; i < to; i++) {\n                    const address = this._addressFromIndex(pathBase, i);\n                    accounts.push({\n                        address,\n                        balance: null,\n                        index: i,\n                    });\n                    this.paths[toChecksumAddress(address)] = i;\n                }\n                resolve(accounts);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    getAccounts() {\n        return Promise.resolve(this.accounts);\n    }\n\n    removeAccount(address: string): void {\n        if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {\n            throw new Error(`Address ${address} not found in this keyring`);\n        }\n        this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase());\n    }\n\n    // tx is an instance of the ethereumjs-transaction class.\n\n    private static serializeTx(tx: Transaction): Buffer {\n        // need use EIP-155\n        // @ts-ignore\n        tx.v = new BN(tx.common.chainId());\n        // @ts-ignore\n        tx.r = new BN(0);\n        // @ts-ignore\n        tx.s = new BN(0);\n        return tx.serialize();\n    }\n\n    async signTransaction(address: string, tx: Transaction): Promise<Transaction> {\n        const hdPath = this._pathFromAddress(address);\n        const chainId = tx.common.chainId();\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            BaseKeyring.serializeTx(tx),\n            DataType.transaction,\n            hdPath,\n            this.xfp,\n            requestId,\n            chainId,\n        );\n\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed the transaction, click on \"Scan Keystone\" to receive the signature',\n        );\n        const txJson = tx.toJSON();\n        return Transaction.fromTxData(\n            {\n                to: txJson['to'],\n                gasLimit: txJson['gasLimit'],\n                gasPrice: txJson['gasPrice'],\n                data: txJson['data'],\n                nonce: txJson['nonce'],\n                value: txJson['value'],\n                r,\n                s,\n                v,\n            },\n            { common: tx.common },\n        );\n    }\n\n    signMessage(withAccount: string, data: string): Promise<string> {\n        return this.signPersonalMessage(withAccount, data);\n    }\n\n    async signPersonalMessage(withAccount: string, messageHex: string): Promise<string> {\n        const usignedHex = stripHexPrefix(messageHex);\n        const hdPath = this._pathFromAddress(withAccount);\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            Buffer.from(usignedHex, 'hex'),\n            DataType.personalMessage,\n            hdPath,\n            this.xfp,\n            requestId,\n            undefined,\n            withAccount,\n        );\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature',\n        );\n        return '0x' + Buffer.concat([r, s, v]).toString('hex');\n    }\n\n    async signTypedData(withAccount: string, typedData: any): Promise<string> {\n        const hdPath = this._pathFromAddress(withAccount);\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            Buffer.from(JSON.stringify(typedData), 'utf-8'),\n            DataType.typedData,\n            hdPath,\n            this.xfp,\n            requestId,\n            undefined,\n            withAccount,\n        );\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed this data, click on \"Scan Keystone\" to receive the signature',\n        );\n        return '0x' + Buffer.concat([r, s, v]).toString('hex');\n    }\n\n    _addressFromIndex(pb: string, i: number): string {\n        this.checkKeyring();\n        if (!this.hdk) {\n            // @ts-ignore\n            this.hdk = HDKey.fromExtendedKey(this.xpub);\n        }\n        const dkey = this.hdk.derive(`${pb}/0/${i}`);\n        const address = '0x' + publicToAddress(dkey.publicKey, true).toString('hex');\n        return toChecksumAddress(address);\n    }\n\n    _pathFromAddress(address: string): string {\n        const checksummedAddress = toChecksumAddress(address);\n        let index = this.paths[checksummedAddress];\n        if (typeof index === 'undefined') {\n            for (let i = 0; i < MAX_INDEX; i++) {\n                if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n\n        if (typeof index === 'undefined') {\n            throw new Error('Unknown address');\n        }\n        return `${this.hdPath}/0/${index}`;\n    }\n}\n"],"names":["BaseKeyring","constructor","opts","Error","async","cryptoHDKey","this","getInteraction","readCryptoHDKey","hdPath","getOrigin","getPath","xfp","getSourceFingerprint","_cryptoHDKey$getOrigi","toString","xpub","getBip32Key","_requestId","signRequest","requestTitle","requestDescription","ethSignature","requestSignature","requestIdBuffer","getRequestId","signature","getSignature","uuid","r","slice","s","v","page","perPage","accounts","currentAccount","paths","latestAccount","deserialize","readKeyringCryptoHDKey","checkKeyring","serialize","Promise","resolve","setCurrentAccount","index","getCurrentAccount","getCurrentAddress","addAccounts","n","reject","from","to","newAccounts","i","address","_addressFromIndex","push","concat","e","getFirstPage","__getPage","getNextPage","getPreviousPage","increment","readKeyring","balance","toChecksumAddress","getAccounts","removeAccount","map","a","toLowerCase","includes","filter","tx","BN","common","chainId","_pathFromAddress","requestId","ethSignRequest","EthSignRequest","constructETHRequest","serializeTx","DataType","transaction","txJson","toJSON","Transaction","fromTxData","gasLimit","gasPrice","data","nonce","value","signMessage","withAccount","signPersonalMessage","messageHex","usignedHex","stripHexPrefix","Buffer","personalMessage","undefined","typedData","JSON","stringify","pb","hdk","HDKey","fromExtendedKey","dkey","derive","publicToAddress","publicKey","checksummedAddress"],"mappings":"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"}