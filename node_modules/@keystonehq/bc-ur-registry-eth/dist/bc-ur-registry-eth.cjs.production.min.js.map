{"version":3,"file":"bc-ur-registry-eth.cjs.production.min.js","sources":["../src/RegistryType.ts","../src/EthSignRequest.ts","../src/EthSignature.ts","../src/utlis.ts","../src/index.ts"],"sourcesContent":["import { extend } from '@keystonehq/bc-ur-registry';\nconst { RegistryType } = extend;\n\nexport const ExtendedRegistryTypes = {\n    ETH_SIGN_REQUEST: new RegistryType('eth-sign-request', 401),\n    ETH_SIGNATAURE: new RegistryType('eth-signature', 402),\n};\n","import { CryptoKeypath, extend, DataItem, PathComponent, RegistryItem } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\nimport * as uuid from 'uuid';\n\nconst { decodeToDataItem, RegistryTypes } = extend;\n\nenum Keys {\n    requestId = 1,\n    signData,\n    dataType,\n    chainId,\n    derivationPath,\n    address,\n    origin\n}\n\nexport enum DataType {\n    transaction = 1,\n    typedData = 2,\n    personalMessage = 3,\n    typedTransaction = 4,\n}\n\ntype signRequestProps = {\n    requestId?: Buffer;\n    signData: Buffer;\n    dataType: DataType;\n    chainId?: number;\n    derivationPath: CryptoKeypath;\n    address?: Buffer;\n    origin?: String;\n};\n\nexport class EthSignRequest extends RegistryItem {\n    private requestId: Buffer;\n    private signData: Buffer;\n    private dataType: DataType;\n    private chainId: number;\n    private derivationPath: CryptoKeypath;\n    private address: Buffer;\n    private origin: String;\n\n    getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;\n\n    constructor(args: signRequestProps) {\n        super();\n        this.setupData(args);\n    }\n\n    private setupData = (args: signRequestProps) => {\n        this.requestId = args.requestId;\n        this.signData = args.signData;\n        this.dataType = args.dataType;\n        this.chainId = args.chainId;\n        this.derivationPath = args.derivationPath;\n        this.address = args.address;\n        this.origin = args.origin;\n    };\n\n    public getRequestId = () => this.requestId;\n    public getSignData = () => this.signData;\n    public getDataType = () => this.dataType;\n    public getChainId = () => this.chainId;\n    public getDerivationPath = () => this.derivationPath.getPath();\n    public getSignRequestAddress = () => this.address;\n    public getOrigin = () => this.origin;\n\n    public toDataItem = () => {\n        const map = {};\n        if (this.requestId) {\n            map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());\n        }\n        if (this.address) {\n            map[Keys.address] = this.address;\n        }\n        if (this.chainId) {\n            map[Keys.chainId] = this.chainId;\n        }\n\n        if(this.origin) {\n            map[Keys.origin] = this.origin;\n        }\n\n        map[Keys.signData] = this.signData;\n        map[Keys.dataType] = this.dataType;\n\n        const keyPath = this.derivationPath.toDataItem();\n        keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n        map[Keys.derivationPath] = keyPath;\n\n        return new DataItem(map);\n    };\n\n    public static fromDataItem = (dataItem) => {\n        const map = dataItem.getData();\n        const signData = map[Keys.signData];\n        const dataType = map[Keys.dataType];\n        const derivationPath = CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n        const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;\n        const address = map[Keys.address] ? map[Keys.address] : undefined;\n        const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n        const origin = map[Keys.origin] ? map[Keys.origin] : undefined;\n\n        return new EthSignRequest({\n            requestId,\n            signData,\n            dataType,\n            chainId,\n            derivationPath,\n            address,\n            origin\n        });\n    };\n\n    public static fromCBOR = (_cborPayload: Buffer) => {\n        const dataItem = decodeToDataItem(_cborPayload);\n        return EthSignRequest.fromDataItem(dataItem);\n    };\n\n    public static constructETHRequest(\n        signData: Buffer,\n        signDataType: DataType,\n        hdPath: string,\n        xfp: string,\n        uuidString?: string,\n        chainId?: number,\n        address?: string,\n        origin?: string,\n    ) {\n        const paths = hdPath.replace(/[m|M]\\//, '').split('/');\n        const hdpathObject = new CryptoKeypath(\n            paths.map((path) => {\n                const index = parseInt(path.replace(\"'\", ''));\n                let isHardened = false;\n                if (path.endsWith(\"'\")) {\n                    isHardened = true;\n                }\n                return new PathComponent({ index, hardened: isHardened });\n            }),\n            Buffer.from(xfp, 'hex'),\n        );\n\n        return new EthSignRequest({\n            requestId: uuidString ? Buffer.from(uuid.parse(uuidString) as Uint8Array) : undefined,\n            signData,\n            dataType: signDataType,\n            derivationPath: hdpathObject,\n            chainId,\n            address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,\n            origin: origin || undefined,\n        });\n    }\n}\n","import { extend, DataItem, RegistryItem } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\n\nconst { RegistryTypes, decodeToDataItem } = extend;\n\nenum Keys {\n    requestId = 1,\n    signature,\n}\n\nexport class ETHSignature extends RegistryItem {\n    private requestId: Buffer;\n    private signature: Buffer;\n\n    getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;\n\n    constructor(signature: Buffer, requestId?: Buffer) {\n        super();\n        this.signature = signature;\n        this.requestId = requestId;\n    }\n\n    public getRequestId = () => this.requestId;\n    public getSignature = () => this.signature;\n\n    public toDataItem = () => {\n        const map = {};\n        if (this.requestId) {\n            map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());\n        }\n        map[Keys.signature] = this.signature;\n        return new DataItem(map);\n    };\n\n    public static fromDataItem = (dataItem) => {\n        const map = dataItem.getData();\n        const signature = map[Keys.signature];\n        const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n\n        return new ETHSignature(signature, requestId);\n    };\n\n    public static fromCBOR = (_cborPayload: Buffer) => {\n        const dataItem = decodeToDataItem(_cborPayload);\n        return ETHSignature.fromDataItem(dataItem);\n    };\n}\n","// @ts-ignore\nimport HDKey from 'hdkey';\nimport { toChecksumAddress, publicToAddress } from 'ethereumjs-util';\n\nexport const generateAddressfromXpub = (xpub: string, derivePath: string) => {\n    // @ts-ignore\n    const node = HDKey.fromExtendedKey(xpub);\n    const publicKey = node.derive(derivePath);\n    const address = '0x' + publicToAddress(publicKey.publicKey, true).toString('hex');\n    return toChecksumAddress(address);\n};\n\nexport const findHDpatfromAddress = (address: string, xpub: string, numberLimit: number, rootPath: string) => {\n    for (let i = 0; i < numberLimit; i++) {\n        const path = `M/0/${i}`;\n        const caculateAddress = generateAddressfromXpub(xpub, path);\n        if (address.toLowerCase() == caculateAddress.toLowerCase()) {\n            return `${rootPath}/0/${i}`;\n        }\n    }\n    return null;\n};\n","export * from '@keystonehq/bc-ur-registry';\nimport { extend } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\nconst { cbor } = extend;\ncbor.patchTags(\n    Object.values(ExtendedRegistryTypes)\n        .filter((rt) => !!rt.getTag())\n        .map((rt) => rt.getTag()),\n);\n\nexport { EthSignRequest, DataType } from './EthSignRequest';\nexport { ETHSignature } from './EthSignature';\n\nexport { generateAddressfromXpub, findHDpatfromAddress } from './utlis';\n"],"names":["RegistryType","extend","ExtendedRegistryTypes","ETH_SIGN_REQUEST","ETH_SIGNATAURE","decodeToDataItem","RegistryTypes","Keys","DataType","EthSignRequest","RegistryItem","constructor","args","requestId","signData","dataType","chainId","derivationPath","address","origin","this","getPath","map","DataItem","UUID","getTag","keyPath","toDataItem","setTag","getRegistryType","setupData","signDataType","hdPath","xfp","uuidString","paths","replace","split","hdpathObject","CryptoKeypath","path","index","parseInt","isHardened","endsWith","PathComponent","hardened","Buffer","from","uuid","undefined","dataItem","getData","fromDataItem","_cborPayload","ETHSignature","signature","generateAddressfromXpub","xpub","derivePath","publicKey","HDKey","fromExtendedKey","derive","publicToAddress","toString","toChecksumAddress","cbor","patchTags","Object","values","filter","rt","numberLimit","rootPath","i","caculateAddress","toLowerCase"],"mappings":"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"}